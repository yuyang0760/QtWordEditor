# 工具栏样式显示逻辑详细设计文档

## 目录
1. [需求概述](#1-需求概述)
2. [核心概念澄清](#2-核心概念澄清)
3. [详细设计方案](#3-详细设计方案)
4. [当前输入样式机制设计](#4-当前输入样式机制设计)
5. [简化后的实现方案](#5-简化后的实现方案)
6. [更新计划](#6-更新计划)
7. [交互流程图](#7-交互流程图)
8. [测试用例](#8-测试用例)

---

## 1. 需求概述

### 1.1 问题背景
在文字处理器中，当用户选中文本时，工具栏应该显示什么样的样式状态，这是一个关键的用户体验问题。

### 1.2 具体需求
- **无选区时**：显示光标前一个字符的样式
- **有选区时**：显示**选区终点（Focus）前一个字符**的样式（无论选区内样式是否一致）

### 1.3 关键区别
| 术语 | 说明 |
|------|------|
| **最后一个选中字符** | 选区的终点位置的字符（取决于选择方向） |
| **选区的最后一个字符** | 选区在文档中的物理最后位置的字符 |
| **文档的最后一个字符** | 整个文档的结尾字符 |

---

## 2. 核心概念澄清

### 2.1 选区的两个关键位置

在文本选择系统中，选区有两个重要的位置：

```
┌─────────────────────────────────────────────────────────┐
│  H e l l o   W o r l d                                 │
│  ↑         ↑                                           │
│  Anchor   Focus                                        │
│  (起点)   (终点)                                       │
└─────────────────────────────────────────────────────────┘
```

- **Anchor（锚点）**：选择开始时的位置，固定不变
- **Focus（焦点）**：选择结束时的位置，随鼠标/键盘移动

### 2.2 选择方向与最后一个选中字符

**场景 A：从左向右选择**
```
文本:    H e l l o   W o r l d
选择:    [ A n c h o r → F o c u s ]
         ↑                   ↑
       起点                 终点
                           ↑
                    最后一个选中字符 = 'd'
```

**场景 B：从右向左选择**
```
文本:    H e l l o   W o r l d
选择:    [ F o c u s ← A n c h o r ]
         ↑                   ↑
       终点                 起点
         ↑
    最后一个选中字符 = 'H'
```

### 2.3 关键结论
✅ **最后一个选中字符 = Focus 位置的前一个字符**

---

## 3. 详细设计方案

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        MainWindow                                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  1. 监听光标/选区变化                                     │  │
│  │  2. 调用 FormatController 获取样式信息                   │  │
│  │  3. 更新 RibbonBar 显示                                  │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                    FormatController                              │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  - getStyleAtPosition(): 获取指定位置样式                 │  │
│  │  - getCurrentDisplayStyle(): 获取当前应显示的样式         │  │
│  │  - getCurrentInputStyle(): 获取当前输入样式               │  │
│  │  - setCurrentInputStyle(): 设置当前输入样式               │  │
│  │  - onCursorMoved(): 光标移动时的处理                      │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                       RibbonBar                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  - updateFromSelection(style): 更新工具栏显示              │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 FormatController 核心方法

#### 3.2.1 getCurrentDisplayStyle() - 获取当前应该显示的样式
```cpp
/**
 * @brief 获取当前应该在工具栏显示的样式
 * 
 * 逻辑：
 * - 有选区：返回选区终点（Focus）的前一个字符的样式
 * - 无选区：返回光标前一个字符的样式
 * 
 * @return 应该显示的字符样式
 */
CharacterStyle getCurrentDisplayStyle() const;
```

#### 3.2.2 getStyleAtPosition() - 获取指定位置的样式
```cpp
/**
 * @brief 获取指定位置的字符样式
 * 
 * @param blockIndex 块索引
 * @param offset 块内偏移量
 * @return 该位置的字符样式
 */
CharacterStyle getStyleAtPosition(int blockIndex, int offset) const;
```

### 3.3 getCurrentDisplayStyle() 实现逻辑

```
函数开始
    ↓
┌─────────────────────────────┐
│  是否有选区？               │
└─────────────┬───────────────┘
              │
       ┌──────┴───────┐
       │              │
      有            无
       │              │
       ↓              ↓
┌─────────────┐  ┌─────────────┐
│ 获取选区终点 │  │ 获取光标位置 │
│ (Focus)     │  │             │
└──────┬──────┘  └──────┬──────┘
       │                 │
       ↓                 ↓
┌─────────────────────────────┐
│ 计算目标位置 = 终点 - 1    │
└──────────────┬──────────────┘
               │
               ↓
┌─────────────────────────────┐
│ 获取目标位置的样式          │
└──────────────┬──────────────┘
               │
               ↓
        返回该样式
```

### 3.4 Selection 类已有的能力

从代码分析，当前 `Selection` 类已经支持：
- `SelectionRange` 结构体包含 `anchorBlock/Offset` 和 `focusBlock/Offset`
- `focusPosition()` 方法获取焦点位置
- `isEmpty()` 方法判断是否有选区

---

## 4. 当前输入样式机制设计

### 4.1 问题背景

在文字编辑器中，存在两种典型的输入场景：

**场景 1：直接打字（继承前一个字符样式）**
```
文本:    [普通][粗体][普通]
          ↑
         光标位置

操作:    直接输入 "x"

结果:    "x" 继承光标前字符的样式（粗体）
```

**场景 2：先设置样式再打字（使用用户设置的样式）**
```
文本:    [普通][粗体][普通]
          ↑
         光标位置

操作:    点击工具栏"斜体"按钮 → 输入 "x"

结果:    "x" 使用用户设置的样式（斜体），而不是继承粗体
```

### 4.2 核心概念

引入关键变量：**`m_currentInputStyle`**

| 概念 | 说明 |
|------|------|
| **当前输入样式** | 用户接下来打字时应该使用的字符样式 |
| **显示样式** | 工具栏当前显示的样式（用于UI反馈） |
| **继承模式** | `m_currentInputStyle` 跟随光标移动而变化，继承前一个字符样式 |
| **覆盖模式** | 用户显式设置工具栏样式后，`m_currentInputStyle` 被固定，直到光标移动 |

### 4.3 状态机设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        状态转换图                                  │
└─────────────────────────────────────────────────────────────────┘

初始状态：继承模式
    ↓
┌─────────────────────────────────────────────────────────────────┐
│  [继承模式]                                                       │
│  - 光标移动时：m_currentInputStyle = 前一个字符样式              │
│  - 打字时：使用 m_currentInputStyle                              │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 用户点击工具栏样式按钮
    ↓
┌─────────────────────────────────────────────────────────────────┐
│  [覆盖模式]                                                       │
│  - m_currentInputStyle = 用户设置的样式                          │
│  - 打字时：使用 m_currentInputStyle                              │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 用户移动光标
    ↓
回到 [继承模式]
```

### 4.4 FormatController 成员变量

```cpp
private:
    CharacterStyle m_currentInputStyle;  ///< 当前输入样式
    bool m_isInputStyleOverridden;       ///< 是否处于覆盖模式（用户手动设置过样式）
```

### 4.5 FormatController 相关方法

```cpp
public:
    /**
     * @brief 获取当前输入样式（用于打字时使用）
     * @return 当前应该使用的输入样式
     */
    CharacterStyle getCurrentInputStyle() const;

    /**
     * @brief 设置当前输入样式（用户通过工具栏手动设置样式时调用）
     * @param style 用户设置的样式
     */
    void setCurrentInputStyle(const CharacterStyle &style);

    /**
     * @brief 光标移动时调用，更新当前输入样式（继承模式）
     */
    void onCursorMoved();
```

---

## 5. 简化后的实现方案

### 5.1 核心思路（关键简化点）

**无论是否有选区，都直接使用 `getCurrentDisplayStyle()`**

该方法内部已经能够处理：
- **无选区时**：返回光标前一个字符的样式
- **有选区时**：返回选区终点（Focus）前一个字符的样式

### 5.2 三种场景总结

| 场景 | 说明 | 工具栏显示 |
|------|------|------------|
| **场景1：无选区** | 只有光标，没有选中文本 | 光标前一个字符的样式 |
| **场景2：有选区且样式一致** | 选区内所有字符样式完全相同 | 选区终点前一个字符的样式（即统一样式） |
| **场景3：有选区但样式不一致** | 选区内有多种不同样式 | **和无选区一样**：显示选区终点（Focus）前一个字符的样式 |

### 5.3 设计简化说明

**关键点**：
- ✅ 不需要实现"三态显示"（部分选中状态）
- ✅ 当样式不一致时，回退到显示选区终点前一个字符的样式
- ✅ 这样可以大大简化实现，同时保持良好的用户体验
- ✅ 不需要新增 `StyleConsistency` 结构体
- ✅ 不需要新增 `getSelectionStyleConsistency()` 方法
- ✅ 不需要 `updateFromSelectionWithConsistency()` 方法

### 5.4 MainWindow::updateStyleState() 简化重写逻辑

```cpp
void MainWindow::updateStyleState()
{
    if (!m_ribbonBar || !m_document || !m_formatController) {
        return;
    }
    
    // ========== 简化逻辑：无论是否有选区，都使用 getCurrentDisplayStyle() ==========
    // 该方法内部已经处理了：
    // - 无选区：返回光标前一个字符的样式
    // - 有选区：返回选区终点前一个字符的样式
    CharacterStyle style = m_formatController->getCurrentDisplayStyle();
    
    // 更新 RibbonBar 的样式显示
    m_ribbonBar->updateFromSelection(style);
}
```

### 5.5 关于 Span 分割

**结论**：保持当前 `ParagraphBlock::setStyle()` 的实现不变。

当前实现已经很完善：
- 自动分割跨越的 Span
- 应用新样式
- 合并相邻相同样式的 Span

---

## 6. 更新计划

### 6.1 阶段 1：确认现有代码状态
**目标**：确认 Selection、FormatController 等类的现有能力

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 1.1 确认 Selection 类能力 | 确认已有 anchor/focus 和 focusPosition() | 10 分钟 |
| 1.2 确认 FormatController 类能力 | 确认已有 getCurrentDisplayStyle() 等方法 | 10 分钟 |
| **小计** | | **20 分钟** |

### 6.2 阶段 2：简化 MainWindow::updateStyleState()
**目标**：移除有选区时不更新工具栏的限制

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 2.1 重写 MainWindow::updateStyleState() | 移除选区判断，直接调用 getCurrentDisplayStyle() | 15 分钟 |
| **小计** | | **15 分钟** |

### 总体时间估算

| 阶段 | 时间 |
|------|------|
| 阶段 1：确认现有代码状态 | 20 分钟 |
| 阶段 2：简化 updateStyleState() | 15 分钟 |
| **总计** | **35 分钟** |

---

## 7. 交互流程图

### 7.1 完整的显示更新流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    触发事件（光标移动/选区变化）                │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  MainWindow::updateStyleState()                                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 1. 直接调用 FormatController::getCurrentDisplayStyle() │  │
│  │    (该方法内部已处理有无选区的情况)                     │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  FormatController::getCurrentDisplayStyle()                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 2. 检查是否有选区                                        │  │
│  │    ├─ 有选区：→ 获取焦点位置（Focus）                   │  │
│  │    │         → 目标位置 = 焦点位置 - 1                 │  │
│  │    │         → 获取该位置的样式                          │  │
│  │    │                                                      │  │
│  │    └─ 无选区：→ 获取光标位置                            │  │
│  │              → 目标位置 = 光标位置 - 1                 │  │
│  │              → 获取该位置的样式                          │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  返回 CharacterStyle 给 MainWindow                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  MainWindow 调用 RibbonBar::updateFromSelection(style)       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  RibbonBar::updateFromSelection()                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 1. 使用 QSignalBlocker 防止信号循环                      │  │
│  │ 2. 更新所有样式控件显示（字体、字号、粗体、斜体等）       │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    ✅ 工具栏显示更新完成！                        │
└─────────────────────────────────────────────────────────────────┘
```

---

## 8. 测试用例

### 8.1 测试场景 1：无选区，光标在中间

**测试步骤：**
1. 打开文档，输入 "Hello World"
2. 移动光标到 "Hello" 和 "World" 之间（即空格后）
3. 设置 "Hello" 为粗体，"World" 为普通样式
4. 将光标放在空格后（"World" 前）

**预期结果：**
- 工具栏显示：光标前字符（空格）的样式

---

### 8.2 测试场景 2：有选区，从左到右选择

**测试步骤：**
1. 输入 "ABCDE"
2. 设置 "A" 为普通，"B" 为粗体，"C" 为斜体，"D" 为粗斜体，"E" 为普通
3. 从左到右选择 "BCD"（从 B 开始，到 E 之前结束）

**选区图示：**
```
A [ B C D ] E
  ↑       ↑
Anchor  Focus
         ↑
      最后一个选中字符是 D
```

**预期结果：**
- 工具栏显示：D 的样式（粗斜体）

---

### 8.3 测试场景 3：有选区，从右到左选择

**测试步骤：**
1. 输入 "ABCDE"
2. 设置样式同上
3. 从右到左选择 "BCD"（从 D 开始，到 A 之后结束）

**选区图示：**
```
A [ B C D ] E
    ↑       ↑
  Focus   Anchor
    ↑
最后一个选中字符是 B
```

**预期结果：**
- 工具栏显示：B 的样式（粗体）

---

### 8.4 测试场景 4：有选区且样式一致

**测试步骤：**
1. 输入 "Hello World"
2. 全部设置为粗体
3. 选中整个文本

**预期结果：**
- 工具栏显示：选区终点前一个字符的样式（粗体）

---

### 8.5 测试场景 5：有选区且样式不一致（部分粗体）

**测试步骤：**
1. 输入 "Hello World"
2. 设置 "Hello" 为粗体，"World" 为普通
3. 从左到右选中整个文本（Focus 在最后）

**预期结果：**
- 工具栏显示：选区终点前一个字符（'d'）的样式（普通）

---

### 8.6 测试场景 6：有选区且多种样式混合

**测试步骤：**
1. 输入 "ABCDE"
2. A: 普通, B: 粗体, C: 斜体, D: 粗斜体, E: 普通
3. 从左到右选中 "ABCDE"

**预期结果：**
- 工具栏显示：选区终点前一个字符（'E'）的样式（普通）

---

### 8.7 测试场景 7：当前输入样式 - 继承模式（直接打字）

**测试步骤：**
1. 输入 "Hello World"，其中 "Hello" 为粗体，"World" 为普通
2. 将光标放在 "World" 的开头（空格后）
3. 直接输入 "x"

**预期结果：**
- "x" 继承光标前字符（空格）的样式（普通样式）

---

### 8.8 测试场景 8：当前输入样式 - 覆盖模式（先设置样式再打字）

**测试步骤：**
1. 输入 "Hello World"，其中 "Hello" 为粗体，"World" 为普通
2. 将光标放在 "World" 的开头（空格后）
3. 点击工具栏"粗体"按钮
4. 输入 "x"

**预期结果：**
- "x" 使用用户设置的样式（粗体），而不是继承空格的普通样式

---

## 文档信息

- **创建日期**：2026-02-18
- **版本**：v5.0（最终简化版）
- **作者**：QtWordEditor 开发团队
- **状态**：待实现
- **更新记录**：
  - v1.0 (2026-02-18): 初始版本，工具栏显示逻辑
  - v2.0 (2026-02-18): 添加当前输入样式机制设计
  - v3.0 (2026-02-19): 添加样式一致性与三态显示设计
  - v4.0 (2026-02-19): 简化设计，移除三态显示
  - v5.0 (2026-02-19): 重新整理结构，确保内容前后一致
