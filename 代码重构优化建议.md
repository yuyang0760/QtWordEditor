# QtWordEditor 代码重构优化建议

**日期**: 2026-02-20
**版本**: v3.0

---

## 目录

1. [总体概述](#总体概述)
2. [第一阶段：FormatController 优化（高优先级）](#第一阶段formatcontroller-优化高优先级)
   - [问题 1：样式一致性检查方法重复](#问题-1样式一致性检查方法重复)
   - [问题 2：样式设置方法重复](#问题-2样式设置方法重复)
   - [问题 3：跨块 Span 收集逻辑重复](#问题-3跨块-span-收集逻辑重复)
   - [问题 4：选区有效性检查重复](#问题-4选区有效性检查重复)
   - [问题 13：段落样式设置方法重复](#问题-13段落样式设置方法重复)
3. [第二阶段：MainWindow 优化（高优先级）](#第二阶段mainwindow-优化高优先级)
   - [问题 5：样式按钮点击处理代码重复](#问题-5样式按钮点击处理代码重复)
   - [问题 6：调试输出重复](#问题-6调试输出重复)
   - [问题 14：字体字号信号处理代码重复](#问题-14字体字号信号处理代码重复)
   - [问题 15：样式管理器信号处理重复](#问题-15样式管理器信号处理重复)
4. [第三阶段：CharacterStyle & ParagraphStyle 优化（中优先级）](#第三阶段characterstyle--paragraphstyle-优化中优先级)
   - [问题 7：属性设置方法模式重复（CharacterStyle）](#问题-7属性设置方法模式重复characterstyle)
   - [问题 8：属性设置方法模式重复（ParagraphStyle）](#问题-8属性设置方法模式重复paragraphstyle)
   - [问题 9：mergeWith 方法属性检查重复](#问题-9mergewith-方法属性检查重复)
5. [第四阶段：ParagraphBlock 优化（中优先级）](#第四阶段paragraphblock-优化中优先级)
   - [问题 10：位置查找和遍历代码重复](#问题-10位置查找和遍历代码重复)
   - [问题 11：qDebug() 调试输出过多](#问题-11qdebug-调试输出过多)
   - [问题 16：边界检查和参数验证代码重复](#问题-16边界检查和参数验证代码重复)
6. [第五阶段：RibbonBar 优化（低优先级）](#第五阶段ribbonbar-优化低优先级)
   - [问题 12：样式按钮创建和信号连接重复](#问题-12样式按钮创建和信号连接重复)
   - [问题 17：对齐按钮创建代码重复](#问题-17对齐按钮创建代码重复)
   - [问题 18：updateFromSelection 方法属性更新代码重复](#问题-18updatefromselection-方法属性更新代码重复)
   - [问题 19：下拉框更新代码重复](#问题-19下拉框更新代码重复)
7. [第六阶段：通用优化（低优先级）](#第六阶段通用优化低优先级)
   - [问题 20：日志系统统一](#问题-20日志系统统一)
   - [问题 21：常量定义优化](#问题-21常量定义优化)
8. [具体优化实施步骤](#具体优化实施步骤)
9. [预期收益](#预期收益)

---

## 总体概述

经过对代码的全面深入分析，发现了**21大类**优化点，涵盖多个文件。主要问题集中在：

1. **代码高度重复**（多个方法逻辑完全相同）
2. **模式重复**（相似的代码模式多次出现）
3. **逻辑重复**（相同的检查和计算在多处执行）
4. **调试输出过多**（影响性能和代码可读性）
5. **属性更新代码重复**（每个属性都有相同的更新模式）

---

## 第一阶段：FormatController 优化（高优先级）

### 问题 1：样式一致性检查方法重复

**文件**：`FormatController.cpp`

**当前状态**：
- 第 572-622 行：`isSelectionAllBold()`
- 第 624-674 行：`isSelectionAllItalic()`
- 第 676-726 行：`isSelectionAllUnderline()`

**问题描述**：
三个方法的代码几乎完全相同，只有检查的属性不同。代码重复率超过 **95%**。

**代码片段对比**：
```cpp
// ========== isSelectionAllBold ==========
bool FormatController::isSelectionAllBold() const
{
    if (!m_selection || m_selection->isEmpty()) {
        return false;
    }
    SelectionRange range = m_selection->range();
    if (range.startBlock < 0) {
        return false;
    }
    
    // 遍历从 startBlock 到 endBlock 的所有块
    for (int blockIndex = range.startBlock; blockIndex <= range.endBlock; ++blockIndex) {
        Block *block = m_document->block(blockIndex);
        ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
        if (!paraBlock) {
            continue;
        }
        
        int blockStartOffset = (blockIndex == range.startBlock) ? range.startOffset : 0;
        int blockEndOffset = (blockIndex == range.endBlock) ? range.endOffset : paraBlock->length();
        
        // 检查当前块中与选区重叠的 Span
        int currentOffset = 0;
        for (int i = 0; i < paraBlock->spanCount(); ++i) {
            const Span &span = paraBlock->span(i);
            int spanStart = currentOffset;
            int spanEnd = spanStart + span.text().length();
            
            if (!(spanEnd <= blockStartOffset || spanStart >= blockEndOffset)) {
                // 唯一区别在这里！
                if (!span.style().bold()) {
                    return false;
                }
            }
            currentOffset = spanEnd;
        }
    }
    return true;
}

// ========== isSelectionAllItalic ==========
// ... 代码完全相同，只有 bold() 改为 italic() ...

// ========== isSelectionAllUnderline ==========
// ... 代码完全相同，只有 bold() 改为 underline() ...
```

**优化方案**：

1. 首先在头文件中添加必要的声明：

```cpp
// ========== FormatController.h 新增 ==========
#include <functional>  // 添加这个头文件

private:
    // 新增：收集选区内所有 Span 的样式
    QList<CharacterStyle> collectSelectionStyles() const;
    
    // 新增：通用的属性检查方法
    bool checkSelectionAll(
        const std::function<bool(const CharacterStyle&)>& checkFunc) const;
```

2. 实现辅助方法：

```cpp
// ========== FormatController.cpp 新增 ==========

/**
 * @brief 收集选区内所有与选区重叠的 Span 的样式
 * @return 样式列表
 */
QList<CharacterStyle> FormatController::collectSelectionStyles() const
{
    QList<CharacterStyle> styles;
    
    if (!m_selection || m_selection->isEmpty()) {
        return styles;
    }
    
    SelectionRange range = m_selection->range();
    if (range.startBlock < 0) {
        return styles;
    }
    
    // 遍历从 startBlock 到 endBlock 的所有块
    for (int blockIndex = range.startBlock; blockIndex <= range.endBlock; ++blockIndex) {
        Block *block = m_document->block(blockIndex);
        ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
        if (!paraBlock) {
            continue;
        }
        
        int blockStartOffset = (blockIndex == range.startBlock) ? range.startOffset : 0;
        int blockEndOffset = (blockIndex == range.endBlock) ? range.endOffset : paraBlock->length();
        
        int currentOffset = 0;
        for (int i = 0; i < paraBlock->spanCount(); ++i) {
            const Span &span = paraBlock->span(i);
            int spanStart = currentOffset;
            int spanEnd = spanStart + span.text().length();
            
            if (!(spanEnd <= blockStartOffset || spanStart >= blockEndOffset)) {
                styles.append(span.style());
            }
            currentOffset = spanEnd;
        }
    }
    
    return styles;
}

/**
 * @brief 通用的属性检查方法
 * @param checkFunc 检查函数，返回 true 表示该 Span 满足条件
 * @return true=所有 Span 都满足条件，false=至少有一个 Span 不满足
 */
bool FormatController::checkSelectionAll(
    const std::function<bool(const CharacterStyle&)>& checkFunc) const
{
    QList<CharacterStyle> styles = collectSelectionStyles();
    if (styles.isEmpty()) {
        return false;
    }
    
    for (const CharacterStyle& style : styles) {
        if (!checkFunc(style)) {
            return false;
        }
    }
    
    return true;
}
```

3. 简化三个方法：

```cpp
// ========== 简化后的方法 ==========

bool FormatController::isSelectionAllBold() const
{
    return checkSelectionAll([](const CharacterStyle& s) { return s.bold(); });
}

bool FormatController::isSelectionAllItalic() const
{
    return checkSelectionAll([](const CharacterStyle& s) { return s.italic(); });
}

bool FormatController::isSelectionAllUnderline() const
{
    return checkSelectionAll([](const CharacterStyle& s) { return s.underline(); });
}
```

**预期收益**：
- 减少代码行数：约 150 行 → 20 行（减少 87%）
- 提高可维护性：新增属性检查只需添加 1 行
- 避免重复逻辑：相同的跨块 Span 收集只在一处

---

### 问题 2：样式设置方法重复

**文件**：`FormatController.cpp`

**当前状态**：
- 第 105-115 行：`setFontFamily()`
- 第 117-127 行：`setFontSize()`
- 第 129-136 行：`setBold()`
- 第 138-145 行：`setItalic()`
- 第 147-154 行：`setUnderline()`
- 第 156-163 行：`setTextColor()`
- 第 165-172 行：`setBackgroundColor()`

**问题描述**：
所有这些方法都遵循完全相同的模式：
1. 创建新的 CharacterStyle
2. 调用 `clearAllProperties()`
3. 设置特定属性
4. 调用 `applyCharacterStyle()`

**代码片段**：
```cpp
void FormatController::setBold(bool bold)
{
    CharacterStyle style;
    style.clearAllProperties();
    style.setBold(bold);
    applyCharacterStyle(style);
}

void FormatController::setItalic(bool italic)
{
    CharacterStyle style;
    style.clearAllProperties();
    style.setItalic(italic);
    applyCharacterStyle(style);
}

void FormatController::setTextColor(const QColor& color)
{
    CharacterStyle style;
    style.clearAllProperties();
    style.setTextColor(color);
    applyCharacterStyle(style);
}
```

**优化方案**：

1. 在头文件中添加声明：

```cpp
// ========== FormatController.h 新增 ==========
private:
    void applySingleProperty(
        const std::function<void(CharacterStyle&)>& setProperty);
```

2. 实现辅助方法：

```cpp
// ========== FormatController.cpp 新增 ==========

/**
 * @brief 通用的单属性样式设置方法
 * @param setProperty 设置属性的函数
 */
void FormatController::applySingleProperty(
    const std::function<void(CharacterStyle&)>& setProperty)
{
    CharacterStyle style;
    style.clearAllProperties();
    setProperty(style);
    applyCharacterStyle(style);
}
```

3. 简化所有方法：

```cpp
// ========== 简化后的方法 ==========

void FormatController::setBold(bool bold)
{
    applySingleProperty([bold](CharacterStyle& s) { s.setBold(bold); });
}

void FormatController::setItalic(bool italic)
{
    applySingleProperty([italic](CharacterStyle& s) { s.setItalic(italic); });
}

void FormatController::setUnderline(bool underline)
{
    applySingleProperty([underline](CharacterStyle& s) { s.setUnderline(underline); });
}

void FormatController::setTextColor(const QColor& color)
{
    applySingleProperty([color](CharacterStyle& s) { s.setTextColor(color); });
}

void FormatController::setBackgroundColor(const QColor& color)
{
    applySingleProperty([color](CharacterStyle& s) { s.setBackgroundColor(color); });
}

void FormatController::setFontFamily(const QString& family)
{
    applySingleProperty([family](CharacterStyle& s) { s.setFontFamily(family); });
}

void FormatController::setFontSize(int size)
{
    applySingleProperty([size](CharacterStyle& s) { s.setFontSize(size); });
}
```

**预期收益**：
- 减少代码行数：约 80 行 → 28 行（减少 65%）
- 提高可维护性：新增属性只需添加 3 行
- 统一错误处理：所有方法使用相同的模式

---

### 问题 3：跨块 Span 收集逻辑重复

**文件**：`FormatController.cpp`

**当前状态**：
- `getSelectionStyleConsistency()` (第 442-560 行) 中有完整的跨块 Span 收集逻辑
- 这个逻辑与我们在问题 1 中要提取的 `collectSelectionStyles()` 完全相同

**问题描述**：
`getSelectionStyleConsistency()` 方法内部也在做完全相同的跨块 Span 收集，导致逻辑重复。

**代码片段**：
```cpp
FormatController::StyleConsistency FormatController::getSelectionStyleConsistency() const
{
    StyleConsistency consistency;
    
    // ========== 这里的逻辑与 collectSelectionStyles() 完全相同！ ==========
    if (!m_selection || m_selection->isEmpty()) {
        return consistency;
    }
    
    SelectionRange range = m_selection->range();
    
    // 收集所有与选区重叠的 Span（支持跨多个块）
    QList<CharacterStyle> selectedStyles;
    
    // 遍历从 startBlock 到 endBlock 的所有块
    for (int blockIndex = range.startBlock; blockIndex <= range.endBlock; ++blockIndex) {
        // ... 完全相同的代码 ...
    }
    // =============================================================
    
    // ... 后续代码 ...
}
```

**优化方案**：
在 `getSelectionStyleConsistency()` 中复用 `collectSelectionStyles()` 方法：

```cpp
FormatController::StyleConsistency FormatController::getSelectionStyleConsistency() const
{
    StyleConsistency consistency;
    
    // ========== 使用公共方法收集样式 ==========
    QList<CharacterStyle> selectedStyles = collectSelectionStyles();
    
    if (selectedStyles.isEmpty()) {
        return consistency;
    }
    
    // 使用第一个 Span 的样式作为基准
    CharacterStyle firstStyle = selectedStyles[0];
    
    // 初始化一致时的属性值
    consistency.consistentFontFamily = firstStyle.fontFamily();
    consistency.consistentFontSize = firstStyle.fontSize();
    consistency.consistentBold = firstStyle.bold();
    consistency.consistentItalic = firstStyle.italic();
    consistency.consistentUnderline = firstStyle.underline();
    
    if (selectedStyles.size() <= 1) {
        return consistency;
    }
    
    // 比较所有 Span 的各个属性
    for (int i = 1; i < selectedStyles.size(); ++i) {
        CharacterStyle currentStyle = selectedStyles[i];
        
        // 检查字体
        if (consistency.fontFamilyConsistent && currentStyle.fontFamily() != firstStyle.fontFamily()) {
            consistency.fontFamilyConsistent = false;
        }
        
        // 检查字号
        if (consistency.fontSizeConsistent && currentStyle.fontSize() != firstStyle.fontSize()) {
            consistency.fontSizeConsistent = false;
        }
        
        // 检查粗体
        if (consistency.boldConsistent && currentStyle.bold() != firstStyle.bold()) {
            consistency.boldConsistent = false;
        }
        
        // 检查斜体
        if (consistency.italicConsistent && currentStyle.italic() != firstStyle.italic()) {
            consistency.italicConsistent = false;
        }
        
        // 检查下划线
        if (consistency.underlineConsistent && currentStyle.underline() != firstStyle.underline()) {
            consistency.underlineConsistent = false;
        }
    }
    
    return consistency;
}
```

**预期收益**：
- 减少代码行数：约 100 行 → 复用已有方法
- 避免逻辑重复：相同的计算只在一处
- 提高一致性：所有使用该逻辑的地方行为一致

---

### 问题 4：选区有效性检查重复

**文件**：`FormatController.cpp`

**当前状态**：
多个方法开头都在做相同的选区有效性检查：
```cpp
if (!m_document || !m_selection)
    return;

SelectionRange range = m_selection->range();
if (range.isEmpty())
    return;

range.normalize();
```

**问题描述**：
相同的检查逻辑在多个方法中重复出现。

**优化方案**：
提取公共的选区验证方法：

```cpp
// ========== FormatController.h 新增 ==========
private:
    bool validateSelection(SelectionRange* outRange = nullptr) const;
```

```cpp
// ========== FormatController.cpp 新增 ==========

/**
 * @brief 验证选区是否有效
 * @param outRange 输出参数，返回归一化后的选区范围
 * @return true=选区有效，false=选区无效
 */
bool FormatController::validateSelection(SelectionRange* outRange) const
{
    if (!m_document || !m_selection) {
        return false;
    }
    
    SelectionRange range = m_selection->range();
    if (range.isEmpty()) {
        return false;
    }
    
    range.normalize();
    
    if (outRange) {
        *outRange = range;
    }
    
    return true;
}
```

**使用示例**：
```cpp
void FormatController::applyCharacterStyle(const CharacterStyle& style)
{
    SelectionRange range;
    if (!validateSelection(&range)) {
        return;
    }
    
    // ... 使用 range 继续处理 ...
}
```

---

### 问题 13：段落样式设置方法重复

**文件**：`FormatController.cpp`

**当前状态**：
- 第 250-255 行：`setAlignment()`
- 第 257-262 行：`setLeftIndent()`
- 第 264-269 行：`setRightIndent()`
- 第 271-276 行：`setFirstLineIndent()`
- 第 278-283 行：`setLineHeight()`
- 第 285-290 行：`setSpaceBefore()`
- 第 292-297 行：`setSpaceAfter()`

**问题描述**：
所有段落样式设置方法都遵循完全相同的模式，与字符样式设置类似。

**代码片段**：
```cpp
void FormatController::setAlignment(QtWordEditor::ParagraphAlignment align)
{
    ParagraphStyle style;
    style.setAlignment(align);
    applyParagraphStyle(style);
}

void FormatController::setLeftIndent(qreal indent)
{
    ParagraphStyle style;
    style.setLeftIndent(indent);
    applyParagraphStyle(style);
}
```

**优化方案**：
类似于字符样式，提取公共方法：

```cpp
// ========== FormatController.h 新增 ==========
private:
    void applySingleParagraphProperty(
        const std::function<void(ParagraphStyle&)>& setProperty);
```

```cpp
// ========== FormatController.cpp 新增 ==========

/**
 * @brief 通用的单段落属性样式设置方法
 * @param setProperty 设置属性的函数
 */
void FormatController::applySingleParagraphProperty(
    const std::function<void(ParagraphStyle&)>& setProperty)
{
    ParagraphStyle style;
    setProperty(style);
    applyParagraphStyle(style);
}
```

```cpp
// ========== 简化后的方法 ==========

void FormatController::setAlignment(QtWordEditor::ParagraphAlignment align)
{
    applySingleParagraphProperty([align](ParagraphStyle& s) { s.setAlignment(align); });
}

void FormatController::setLeftIndent(qreal indent)
{
    applySingleParagraphProperty([indent](ParagraphStyle& s) { s.setLeftIndent(indent); });
}

void FormatController::setRightIndent(qreal indent)
{
    applySingleParagraphProperty([indent](ParagraphStyle& s) { s.setRightIndent(indent); });
}

void FormatController::setFirstLineIndent(qreal indent)
{
    applySingleParagraphProperty([indent](ParagraphStyle& s) { s.setFirstLineIndent(indent); });
}

void FormatController::setLineHeight(int percent)
{
    applySingleParagraphProperty([percent](ParagraphStyle& s) { s.setLineHeight(percent); });
}

void FormatController::setSpaceBefore(qreal space)
{
    applySingleParagraphProperty([space](ParagraphStyle& s) { s.setSpaceBefore(space); });
}

void FormatController::setSpaceAfter(qreal space)
{
    applySingleParagraphProperty([space](ParagraphStyle& s) { s.setSpaceAfter(space); });
}
```

**预期收益**：
- 减少代码行数：约 40 行 → 21 行（减少 48%）
- 统一字符和段落样式设置模式

---

## 第二阶段：MainWindow 优化（高优先级）

### 问题 5：样式按钮点击处理代码重复

**文件**：`MainWindow.cpp`

**当前状态**：
- 第 202-235 行：`boldChanged` 信号处理
- 第 238-270 行：`italicChanged` 信号处理
- 第 272-304 行：`underlineChanged` 信号处理

**问题描述**：
三个 Lambda 函数的逻辑几乎完全相同，只有属性名称不同，代码重复率超过 **90%**。

**代码片段对比**：
```cpp
// ========== 加粗处理 ==========
connect(m_ribbonBar, &RibbonBar::boldChanged,
        this, [this](bool /* bold */) {
    qDebug() << "MainWindow: 加粗按钮被点击";
    
    CharacterStyle style;
    if (m_selection->isEmpty()) {
        CharacterStyle currentStyle = m_formatController->getCurrentDisplayStyle();
        bool newBold = !currentStyle.bold();
        style.setBold(newBold);
        m_formatController->setCurrentInputStyle(style);
    } else {
        bool allBold = m_formatController->isSelectionAllBold();
        bool newBold = allBold ? false : true;
        style.setBold(newBold);
        m_formatController->setBold(newBold);
    }
    updateStyleState();
});

// ========== 斜体处理 ==========
// ... 代码完全相同，只有 bold 改为 italic ...

// ========== 下划线处理 ==========
// ... 代码完全相同，只有 bold 改为 underline ...
```

**优化方案**：

1. 在头文件中添加声明：

```cpp
// ========== MainWindow.h 新增 ==========
#include <functional>

private:
    void toggleStyleAttribute(
        const std::function<bool(const CharacterStyle&)>& getCurrent,
        const std::function<void(CharacterStyle&, bool)>& setStyle,
        const std::function<bool()>& isSelectionAll,
        const std::function<void(bool)>& setFormat,
        const QString& debugName);
```

2. 实现公共方法：

```cpp
// ========== MainWindow.cpp 新增 ==========

/**
 * @brief 通用的样式属性切换方法
 * @param getCurrent 获取当前样式属性的函数
 * @param setStyle 设置样式属性的函数
 * @param isSelectionAll 检查选区是否全部设置了该属性的函数
 * @param setFormat 设置格式的函数
 * @param debugName 调试输出名称
 */
void MainWindow::toggleStyleAttribute(
    const std::function<bool(const CharacterStyle&)>& getCurrent,
    const std::function<void(CharacterStyle&, bool)>& setStyle,
    const std::function<bool()>& isSelectionAll,
    const std::function<void(bool)>& setFormat,
    const QString& debugName)
{
    qDebug() << "MainWindow:" << debugName << "按钮被点击";
    
    CharacterStyle style;
    if (m_selection->isEmpty()) {
        CharacterStyle currentStyle = m_formatController->getCurrentDisplayStyle();
        qDebug() << "  无选区，getCurrentDisplayStyle() 返回的" << debugName << ":" << getCurrent(currentStyle);
        bool newState = !getCurrent(currentStyle);
        qDebug() << "  计算的新" << debugName << ":" << newState;
        setStyle(style, newState);
        m_formatController->setCurrentInputStyle(style);
    } else {
        bool allSet = isSelectionAll();
        qDebug() << "  有选区，选区内全部" << debugName << ":" << allSet;
        
        bool newState;
        if (allSet) {
            newState = false;
            qDebug() << "  选区内全部" << debugName << "，设置为 false";
        } else {
            newState = true;
            qDebug() << "  选区内不一致或未" << debugName << "，设置为 true";
        }
        
        setStyle(style, newState);
        setFormat(newState);
    }
    updateStyleState();
}
```

3. 替换三个 Lambda 连接：

```cpp
// ========== 使用示例 ==========

connect(m_ribbonBar, &RibbonBar::boldChanged,
        this, [this]() {
    toggleStyleAttribute(
        [](const CharacterStyle& s) { return s.bold(); },
        [](CharacterStyle& s, bool v) { s.setBold(v); },
        [this]() { return m_formatController->isSelectionAllBold(); },
        [this](bool v) { m_formatController->setBold(v); },
        "加粗"
    );
});

connect(m_ribbonBar, &RibbonBar::italicChanged,
        this, [this]() {
    toggleStyleAttribute(
        [](const CharacterStyle& s) { return s.italic(); },
        [](CharacterStyle& s, bool v) { s.setItalic(v); },
        [this]() { return m_formatController->isSelectionAllItalic(); },
        [this](bool v) { m_formatController->setItalic(v); },
        "斜体"
    );
});

connect(m_ribbonBar, &RibbonBar::underlineChanged,
        this, [this]() {
    toggleStyleAttribute(
        [](const CharacterStyle& s) { return s.underline(); },
        [](CharacterStyle& s, bool v) { s.setUnderline(v); },
        [this]() { return m_formatController->isSelectionAllUnderline(); },
        [this](bool v) { m_formatController->setUnderline(v); },
        "下划线"
    );
});
```

**预期收益**：
- 减少代码行数：约 100 行 → 40 行（减少 60%）
- 提高可维护性：新增属性只需添加 10 行
- 统一错误处理：所有方法使用相同的模式

---

### 问题 6：调试输出重复

**文件**：`MainWindow.cpp`、`FormatController.cpp`、`ParagraphBlock.cpp`

**当前状态**：
代码中有大量的 `qDebug()` 调试输出，例如：
```cpp
qDebug() << "MainWindow: 加粗按钮被点击";
qDebug() << "  无选区，getCurrentDisplayStyle() 返回的加粗:" << currentStyle.bold();
qDebug() << "  计算的新加粗:" << newBold;
// ... 更多 qDebug() ...
```

**问题描述**：
- 影响性能（即使不显示，qDebug() 也会执行字符串拼接）
- 降低代码可读性
- 生产环境不需要这些输出

**优化方案**：

1. 创建统一的日志头文件 `core/utils/Logger.h`：

```cpp
#ifndef LOGGER_H
#define LOGGER_H

#include <QDebug>
#include <QString>

namespace QtWordEditor {

// 日志级别
enum class LogLevel {
    Debug,
    Info,
    Warning,
    Error
};

class Logger {
public:
    // 启用/禁用调试输出
    static void setDebugEnabled(bool enabled);
    static bool isDebugEnabled();
    
    // 调试输出（仅在调试模式下）
    static void debug(const QString& message);
    static void debug(const char* message);
    
    // 信息输出
    static void info(const QString& message);
    
    // 警告输出
    static void warning(const QString& message);
    
    // 错误输出
    static void error(const QString& message);
    
private:
    static bool s_debugEnabled;
};

} // namespace QtWordEditor

// 便捷宏
#ifdef QT_DEBUG
    #define LOG_DEBUG(msg) QtWordEditor::Logger::debug(msg)
#else
    #define LOG_DEBUG(msg) while(false) qDebug()
#endif

#define LOG_INFO(msg) QtWordEditor::Logger::info(msg)
#define LOG_WARNING(msg) QtWordEditor::Logger::warning(msg)
#define LOG_ERROR(msg) QtWordEditor::Logger::error(msg)

#endif // LOGGER_H
```

2. 创建实现文件 `core/utils/Logger.cpp`：

```cpp
#include "core/utils/Logger.h"

namespace QtWordEditor {

bool Logger::s_debugEnabled = true;

void Logger::setDebugEnabled(bool enabled)
{
    s_debugEnabled = enabled;
}

bool Logger::isDebugEnabled()
{
    return s_debugEnabled;
}

void Logger::debug(const QString& message)
{
#ifdef QT_DEBUG
    if (s_debugEnabled) {
        qDebug() << "[DEBUG]" << message;
    }
#endif
}

void Logger::debug(const char* message)
{
    debug(QString::fromLatin1(message));
}

void Logger::info(const QString& message)
{
    qInfo() << "[INFO]" << message;
}

void Logger::warning(const QString& message)
{
    qWarning() << "[WARNING]" << message;
}

void Logger::error(const QString& message)
{
    qCritical() << "[ERROR]" << message;
}

} // namespace QtWordEditor
```

3. 替换所有 qDebug() 调用：

```cpp
// 替换前
qDebug() << "MainWindow: 加粗按钮被点击";

// 替换后
LOG_DEBUG("MainWindow: 加粗按钮被点击");
```

**预期收益**：
- 提高性能：生产环境无调试输出开销
- 提高代码可读性：减少噪声
- 便于控制：可通过宏开关调试输出
- 统一日志格式

---

### 问题 14：字体字号信号处理代码重复

**文件**：`MainWindow.cpp`

**当前状态**：
- 第 173-187 行：`fontChanged` 信号处理
- 第 189-200 行：`fontSizeChanged` 信号处理

**问题描述**：
两个信号处理函数有相似的模式，都在判断是否有选区，然后调用相应的方法。

**代码片段**：
```cpp
connect(m_ribbonBar, &RibbonBar::fontChanged,
        this, [this](const QFont &font) {
    qDebug() << "字体变化（来自功能区）:" << font;
    // 只设置字体族，不改变字号！
    CharacterStyle style;
    style.clearAllProperties();
    style.setFontFamily(font.family());
    if (m_selection->isEmpty()) {
        m_formatController->setCurrentInputStyle(style);
    } else {
        // 使用单独的 setFontFamily 方法（我们需要添加）
        m_formatController->setFontFamily(font.family());
    }
    updateStyleState();
});

connect(m_ribbonBar, &RibbonBar::fontSizeChanged,
        this, [this](int size) {
    CharacterStyle style;
    style.setFontSize(size);
    if (m_selection->isEmpty()) {
        m_formatController->setCurrentInputStyle(style);
    } else {
        m_formatController->setFontSize(size);
    }
    updateStyleState();
});
```

**优化方案**：
提取公共方法处理字体/字号变更：

```cpp
// ========== MainWindow.h 新增 ==========
private:
    void applyFontProperty(
        const std::function<void(CharacterStyle&)>& setStyle,
        const std::function<void()>& applyFormat,
        const QString& debugName);
```

```cpp
// ========== MainWindow.cpp 新增 ==========

/**
 * @brief 通用的字体属性应用方法
 * @param setStyle 设置样式的函数
 * @param applyFormat 应用格式的函数
 * @param debugName 调试输出名称
 */
void MainWindow::applyFontProperty(
    const std::function<void(CharacterStyle&)>& setStyle,
    const std::function<void()>& applyFormat,
    const QString& debugName)
{
    LOG_DEBUG("字体属性变化（来自功能区）:" + debugName);
    
    CharacterStyle style;
    style.clearAllProperties();
    setStyle(style);
    
    if (m_selection->isEmpty()) {
        m_formatController->setCurrentInputStyle(style);
    } else {
        applyFormat();
    }
    updateStyleState();
}
```

```cpp
// ========== 使用示例 ==========

connect(m_ribbonBar, &RibbonBar::fontChanged,
        this, [this](const QFont &font) {
    applyFontProperty(
        [&font](CharacterStyle& s) { s.setFontFamily(font.family()); },
        [this, &font]() { m_formatController->setFontFamily(font.family()); },
        "字体族"
    );
});

connect(m_ribbonBar, &RibbonBar::fontSizeChanged,
        this, [this](int size) {
    applyFontProperty(
        [size](CharacterStyle& s) { s.setFontSize(size); },
        [this, size]() { m_formatController->setFontSize(size); },
        "字号"
    );
});
```

**预期收益**：
- 减少代码行数：约 30 行 → 15 行（减少 50%）
- 统一字体属性处理逻辑

---

### 问题 15：样式管理器信号处理重复

**文件**：`MainWindow.cpp`

**当前状态**：
- 第 136-170 行：三个样式管理器信号处理函数

**问题描述**：
`characterStyleChanged`、`paragraphStyleChanged`、`stylesChanged` 三个信号处理函数有大量重复代码。

**代码片段**：
```cpp
connect(m_styleManager, &StyleManager::characterStyleChanged,
        this, [this](const QString &styleName) {
    Q_UNUSED(styleName);
    if (m_scene) {
        m_scene->updateAllTextItems();
    }
    // 刷新 RibbonBar 的样式列表
    if (m_ribbonBar) {
        m_ribbonBar->refreshStyleLists();
    }
});

connect(m_styleManager, &StyleManager::paragraphStyleChanged,
        this, [this](const QString &styleName) {
    Q_UNUSED(styleName);
    if (m_scene) {
        m_scene->updateAllTextItems();
    }
    // 刷新 RibbonBar 的样式列表
    if (m_ribbonBar) {
        m_ribbonBar->refreshStyleLists();
    }
});

connect(m_styleManager, &StyleManager::stylesChanged,
        this, [this]() {
    if (m_scene) {
        m_scene->updateAllTextItems();
    }
    // 刷新 RibbonBar 的样式列表
    if (m_ribbonBar) {
        m_ribbonBar->refreshStyleLists();
    }
});
```

**优化方案**：
提取公共槽函数：

```cpp
// ========== MainWindow.h 新增 ==========
private slots:
    void onStyleChanged();
```

```cpp
// ========== MainWindow.cpp 新增 ==========

/**
 * @brief 样式变化时的统一处理
 */
void MainWindow::onStyleChanged()
{
    if (m_scene) {
        m_scene->updateAllTextItems();
    }
    if (m_ribbonBar) {
        m_ribbonBar->refreshStyleLists();
    }
}
```

```cpp
// ========== 使用示例 ==========

connect(m_styleManager, &StyleManager::characterStyleChanged,
        this, &MainWindow::onStyleChanged);

connect(m_styleManager, &StyleManager::paragraphStyleChanged,
        this, &MainWindow::onStyleChanged);

connect(m_styleManager, &StyleManager::stylesChanged,
        this, &MainWindow::onStyleChanged);
```

**预期收益**：
- 减少代码行数：约 40 行 → 10 行（减少 75%）
- 统一样式变化处理逻辑

---

## 第三阶段：CharacterStyle & ParagraphStyle 优化（中优先级）

### 问题 7：属性设置方法模式重复（CharacterStyle）

**文件**：`CharacterStyle.cpp`

**当前状态**：
所有属性设置方法都遵循相同的模式：
```cpp
void CharacterStyle::setFontFamily(const QString &family)
{
    if (d->m_font.family() != family) {
        d->m_font.setFamily(family);
        d->m_propertySetFlags |= CharacterStyleProperty::FontFamily;
    }
}

void CharacterStyle::setFontSize(int size)
{
    if (d->m_font.pointSize() != size) {
        d->m_font.setPointSize(size);
        d->m_propertySetFlags |= CharacterStyleProperty::FontSize;
    }
}

void CharacterStyle::setTextColor(const QColor& color)
{
    if (d->m_textColor != color) {
        d->m_textColor = color;
        d->m_propertySetFlags |= CharacterStyleProperty::TextColor;
    }
}
```

**问题描述**：
这些方法虽然不完全相同，但模式高度相似。不过，由于每个方法操作的属性类型不同，完全统一可能会降低可读性。

**建议**：
保持现状，这些方法虽然有模式重复，但每个方法都很短小，过度抽象反而可能降低可读性。

---

### 问题 8：属性设置方法模式重复（ParagraphStyle）

**文件**：`ParagraphStyle.cpp`

**当前状态**：
与 CharacterStyle 类似，ParagraphStyle 的属性设置方法也有相同的模式。

**建议**：
保持现状，理由同上。

---

### 问题 9：mergeWith 方法属性检查重复

**文件**：`CharacterStyle.cpp`、`ParagraphStyle.cpp`

**当前状态**：
`mergeWith` 方法中对每个属性都做相同的检查：

```cpp
if (other.isPropertySet(CharacterStyleProperty::FontFamily)) {
    result.setFontFamily(other.fontFamily());
}
if (other.isPropertySet(CharacterStyleProperty::FontSize)) {
    result.setFontSize(other.fontSize());
}
// ... 更多类似检查 ...
```

**问题描述**：
这种模式重复是必要的，因为每个属性需要单独处理。

**建议**：
保持现状，这是合理的重复。

---

## 第四阶段：ParagraphBlock 优化（中优先级）

### 问题 10：位置查找和遍历代码重复

**文件**：`ParagraphBlock.cpp`

**当前状态**：
多个方法中都有遍历 Span 查找位置的代码：
- `findSpanIndex()` - 查找 Span 索引
- `characterAt()` - 查找字符
- `setStyle()` - 查找起始和结束 Span

**问题描述**：
虽然 `findSpanIndex()` 已经提取出来，但还有一些相关逻辑可以进一步优化。

**建议**：
当前实现已经比较合理，`findSpanIndex()` 已经被多个方法复用，不需要进一步优化。

---

### 问题 11：qDebug() 调试输出过多

**文件**：`ParagraphBlock.cpp`

**当前状态**：
`setStyle()` 方法中有大量的调试输出（约 40 行）：

```cpp
qDebug() << "ParagraphBlock::setStyle - 开始处理: 位置" << start << "长度" << length;
qDebug() << "  同一个 span 内处理: startSpanIndex=" << startSpanIndex;
qDebug() << "    posInStartSpan=" << posInStartSpan << ", posInEndSpan=" << posInEndSpan;
qDebug() << "    before=[" << before << "], middle=[" << middle << "], after=[" << after << "]";
// ... 更多 qDebug() ...
```

**问题描述**：
- 严重影响性能（即使不显示也会执行）
- 代码中有约 40 行 qDebug() 输出

**优化方案**：
使用统一的日志系统（见问题 6）替换 qDebug()：

```cpp
// 替换前
qDebug() << "ParagraphBlock::setStyle - 开始处理: 位置" << start << "长度" << length;

// 替换后
LOG_DEBUG(QString("ParagraphBlock::setStyle - 开始处理: 位置%1 长度%2").arg(start).arg(length));
```

**预期收益**：
- 提高性能：生产环境零调试输出开销
- 提高代码可读性

---

### 问题 16：边界检查和参数验证代码重复

**文件**：`ParagraphBlock.cpp`

**当前状态**：
`setStyle()`、`insert()`、`remove()` 方法都有相似的边界检查逻辑：

```cpp
// setStyle() 中的检查
if (length <= 0 || m_spans.isEmpty()) {
    return;
}

int end = start + length;
int totalLength = this->length();
start = qBound(0, start, totalLength);
end = qBound(0, end, totalLength);

if (start >= end) {
    return;
}

// remove() 中的检查
if (length <= 0)
    return;

int totalLength = this->length();
int end = position + length;
position = qBound(0, position, totalLength);
end = qBound(0, end, totalLength);

if (position >= end) {
    return;
}
```

**优化方案**：
提取公共的参数验证方法：

```cpp
// ========== ParagraphBlock.h 新增 ==========
private:
    /**
     * @brief 验证位置和长度参数
     * @param position 起始位置（输入输出参数）
     * @param length 长度（输入输出参数）
     * @return true=参数有效，false=参数无效
     */
    bool validatePositionAndLength(int& position, int& length) const;
```

```cpp
// ========== ParagraphBlock.cpp 新增 ==========

bool ParagraphBlock::validatePositionAndLength(int& position, int& length) const
{
    if (length <= 0 || m_spans.isEmpty()) {
        return false;
    }
    
    int totalLength = this->length();
    int end = position + length;
    position = qBound(0, position, totalLength);
    end = qBound(0, end, totalLength);
    length = end - position;
    
    return length > 0;
}
```

```cpp
// ========== 使用示例 ==========

void ParagraphBlock::setStyle(int start, int length, const CharacterStyle &style)
{
    if (!validatePositionAndLength(start, length)) {
        return;
    }
    
    int end = start + length;
    // ... 后续代码 ...
}

void ParagraphBlock::remove(int position, int length)
{
    if (!validatePositionAndLength(position, length)) {
        return;
    }
    
    int end = position + length;
    // ... 后续代码 ...
}
```

**预期收益**：
- 减少代码行数：约 20 行 → 5 行（减少 75%）
- 统一参数验证逻辑
- 确保所有方法使用相同的验证规则

---

## 第五阶段：RibbonBar 优化（低优先级）

### 问题 12：样式按钮创建和信号连接重复

**文件**：`RibbonBar.cpp`

**当前状态**：
- 第 139-149 行：`boldAction` 创建
- 第 151-158 行：`italicAction` 创建
- 第 160-167 行：`underlineAction` 创建

**问题描述**：
三个按钮的创建代码高度相似。

**优化方案**：

1. 在头文件中添加声明：

```cpp
// ========== RibbonBar.h 新增 ==========
#include <functional>

private:
    QAction* createStyleAction(
        const QString& text,
        std::function<void()> emitSignalFunc);
```

2. 实现辅助方法：

```cpp
// ========== RibbonBar.cpp 新增 ==========

/**
 * @brief 创建样式按钮的辅助方法
 * @param text 按钮文本
 * @param emitSignalFunc 发出信号的函数
 * @return 创建的 QAction
 */
QAction* RibbonBar::createStyleAction(
    const QString& text,
    std::function<void()> emitSignalFunc)
{
    QAction* action = new QAction(text, this);
    action->setCheckable(true);
    connect(action, &QAction::triggered, this, [this, action, emitSignalFunc]() {
        QSignalBlocker blocker(action);
        emitSignalFunc();
    });
    return action;
}
```

3. 使用示例：

```cpp
d->boldAction = createStyleAction(tr("B"), [this]() {
    emit boldChanged(false);
});
addAction(d->boldAction);

d->italicAction = createStyleAction(tr("I"), [this]() {
    emit italicChanged(false);
});
addAction(d->italicAction);

d->underlineAction = createStyleAction(tr("U"), [this]() {
    emit underlineChanged(false);
});
addAction(d->underlineAction);
```

**预期收益**：
- 减少代码行数：约 40 行 → 25 行（减少 37%）
- 提高可维护性：新增按钮只需添加 4 行

---

### 问题 17：对齐按钮创建代码重复

**文件**：`RibbonBar.cpp`

**当前状态**：
- 第 172-176 行：`alignLeftAction` 创建
- 第 178-182 行：`alignCenterAction` 创建
- 第 184-188 行：`alignRightAction` 创建
- 第 190-194 行：`alignJustifyAction` 创建

**问题描述**：
四个对齐按钮的创建代码高度相似。

**优化方案**：
扩展 `createStyleAction` 方法或创建新的辅助方法：

```cpp
// ========== RibbonBar.h 新增 ==========
private:
    QAction* createAlignmentAction(
        const QString& text,
        Qt::Alignment alignment);
```

```cpp
// ========== RibbonBar.cpp 新增 ==========

/**
 * @brief 创建对齐按钮的辅助方法
 * @param text 按钮文本
 * @param alignment 对齐方式
 * @return 创建的 QAction
 */
QAction* RibbonBar::createAlignmentAction(
    const QString& text,
    Qt::Alignment alignment)
{
    QAction* action = new QAction(text, this);
    action->setCheckable(true);
    connect(action, &QAction::toggled, this, [this, alignment](bool checked) {
        if (checked) {
            emit alignmentChanged(alignment);
        }
    });
    return action;
}
```

```cpp
// ========== 使用示例 ==========

d->alignLeftAction = createAlignmentAction(tr("左"), Qt::AlignLeft);
addAction(d->alignLeftAction);

d->alignCenterAction = createAlignmentAction(tr("中"), Qt::AlignCenter);
addAction(d->alignCenterAction);

d->alignRightAction = createAlignmentAction(tr("右"), Qt::AlignRight);
addAction(d->alignRightAction);

d->alignJustifyAction = createAlignmentAction(tr("两"), Qt::AlignJustify);
addAction(d->alignJustifyAction);
```

**预期收益**：
- 减少代码行数：约 30 行 → 15 行（减少 50%）
- 统一对齐按钮创建逻辑

---

### 问题 18：updateFromSelection 方法属性更新代码重复

**文件**：`RibbonBar.cpp`

**当前状态**：
- 第 402-479 行：`updateFromSelection(const CharacterStyle&, const StyleConsistency&)` 方法

**问题描述**：
该方法中对每个属性（字体、字号、粗体、斜体、下划线）都有相同的更新模式：

```cpp
// ========== 更新字体 ==========
if (consistency.fontFamilyConsistent) {
    QString fontFamily = consistency.consistentFontFamily;
    bool found = false;
    for (int i = 0; i < d->fontCombo->count(); ++i) {
        if (d->fontCombo->itemText(i) == fontFamily) {
            d->fontCombo->setCurrentIndex(i);
            found = true;
            break;
        }
    }
    if (!found) {
        QFont font;
        font.setFamily(fontFamily);
        d->fontCombo->setCurrentFont(font);
    }
    qDebug() << "  字体一致，设置字体:" << fontFamily;
} else {
    d->fontCombo->setCurrentIndex(-1);
    qDebug() << "  字体不一致，清空";
}

// ========== 更新字号 ==========
if (consistency.fontSizeConsistent) {
    int fontSize = consistency.consistentFontSize;
    d->fontSizeCombo->setCurrentText(QString::number(fontSize));
    qDebug() << "  字号一致，设置字号:" << fontSize;
} else {
    d->fontSizeCombo->setCurrentIndex(-1);
    qDebug() << "  字号不一致，清空";
}

// ... 粗体、斜体、下划线也有类似的模式 ...
```

**优化方案**：
提取公共的属性更新辅助方法：

```cpp
// ========== RibbonBar.h 新增 ==========
private:
    template<typename T>
    void updateStyleProperty(
        bool consistent,
        const T& value,
        const std::function<void(const T&)>& setValue,
        const std::function<void()>& clearValue,
        const QString& propertyName);
    
    void updateFontCombo(const QString& fontFamily);
    void updateAction(QAction* action, bool consistent, bool value, const QString& propertyName);
```

```cpp
// ========== RibbonBar.cpp 新增 ==========

/**
 * @brief 通用的样式属性更新方法
 * @param consistent 属性是否一致
 * @param value 一致时的属性值
 * @param setValue 设置值的函数
 * @param clearValue 清空值的函数
 * @param propertyName 属性名称（用于调试）
 */
template<typename T>
void RibbonBar::updateStyleProperty(
    bool consistent,
    const T& value,
    const std::function<void(const T&)>& setValue,
    const std::function<void()>& clearValue,
    const QString& propertyName)
{
    if (consistent) {
        setValue(value);
        LOG_DEBUG(QString("  %1一致，设置:%2").arg(propertyName).arg(value));
    } else {
        clearValue();
        LOG_DEBUG(QString("  %1不一致，清空").arg(propertyName));
    }
}

/**
 * @brief 更新字体下拉框
 * @param fontFamily 字体族名称
 */
void RibbonBar::updateFontCombo(const QString& fontFamily)
{
    bool found = false;
    for (int i = 0; i < d->fontCombo->count(); ++i) {
        if (d->fontCombo->itemText(i) == fontFamily) {
            d->fontCombo->setCurrentIndex(i);
            found = true;
            break;
        }
    }
    if (!found) {
        QFont font;
        font.setFamily(fontFamily);
        d->fontCombo->setCurrentFont(font);
    }
}

/**
 * @brief 更新动作按钮
 * @param action 动作按钮
 * @param consistent 属性是否一致
 * @param value 一致时的值
 * @param propertyName 属性名称（用于调试）
 */
void RibbonBar::updateAction(QAction* action, bool consistent, bool value, const QString& propertyName)
{
    if (consistent) {
        action->setChecked(value);
        LOG_DEBUG(QString("  %1一致，设置:%2").arg(propertyName).arg(value));
    } else {
        action->setChecked(false);
        LOG_DEBUG(QString("  %1不一致，取消选中").arg(propertyName));
    }
}
```

```cpp
// ========== 使用示例 ==========

void RibbonBar::updateFromSelection(const CharacterStyle &style, const StyleConsistency &consistency)
{
    LOG_DEBUG(QString("RibbonBar::updateFromSelection - 各属性一致性：字体=%1, 字号=%2, 粗体=%3, 斜体=%4, 下划线=%5")
        .arg(consistency.fontFamilyConsistent)
        .arg(consistency.fontSizeConsistent)
        .arg(consistency.boldConsistent)
        .arg(consistency.italicConsistent)
        .arg(consistency.underlineConsistent));

    // 使用 QSignalBlocker 防止信号循环
    QSignalBlocker fontBlocker(d->fontCombo);
    QSignalBlocker fontSizeBlocker(d->fontSizeCombo);
    QSignalBlocker boldBlocker(d->boldAction);
    QSignalBlocker italicBlocker(d->italicAction);
    QSignalBlocker underlineBlocker(d->underlineAction);
    
    // ========== 更新字体 ==========
    updateStyleProperty<QString>(
        consistency.fontFamilyConsistent,
        consistency.consistentFontFamily,
        [this](const QString& fontFamily) { updateFontCombo(fontFamily); },
        [this]() { d->fontCombo->setCurrentIndex(-1); },
        "字体"
    );
    
    // ========== 更新字号 ==========
    updateStyleProperty<int>(
        consistency.fontSizeConsistent,
        consistency.consistentFontSize,
        [this](int size) { d->fontSizeCombo->setCurrentText(QString::number(size)); },
        [this]() { d->fontSizeCombo->setCurrentIndex(-1); },
        "字号"
    );
    
    // ========== 更新粗体 ==========
    updateAction(d->boldAction, consistency.boldConsistent, consistency.consistentBold, "粗体");
    
    // ========== 更新斜体 ==========
    updateAction(d->italicAction, consistency.italicConsistent, consistency.consistentItalic, "斜体");
    
    // ========== 更新下划线 ==========
    updateAction(d->underlineAction, consistency.underlineConsistent, consistency.consistentUnderline, "下划线");
}
```

**预期收益**：
- 减少代码行数：约 80 行 → 30 行（减少 63%）
- 提高可维护性：新增属性只需添加少量代码
- 统一属性更新模式

---

### 问题 19：下拉框更新代码重复

**文件**：`RibbonBar.cpp`

**当前状态**：
- 第 310-332 行：`updateFromSelection(const QString&, const QString&)` 方法
- 第 481-515 行：`refreshStyleLists()` 方法

**问题描述**：
两个方法中都有重复的下拉框更新逻辑。

**代码片段**：
```cpp
// updateFromSelection 中
int paraIndex = d->paragraphStyleCombo->findText(paragraphStyleName);
if (paraIndex >= 0) {
    QSignalBlocker blocker(d->paragraphStyleCombo);
    d->paragraphStyleCombo->setCurrentIndex(paraIndex);
} else {
    QSignalBlocker blocker(d->paragraphStyleCombo);
    d->paragraphStyleCombo->setCurrentIndex(-1);
}

// refreshStyleLists 中
QString currentParaStyle = d->paragraphStyleCombo->currentText();
QSignalBlocker paraBlocker(d->paragraphStyleCombo);
d->paragraphStyleCombo->clear();
QStringList paraStyles = d->styleManager->paragraphStyleNames();
d->paragraphStyleCombo->addItems(paraStyles);
int paraIndex = d->paragraphStyleCombo->findText(currentParaStyle);
if (paraIndex >= 0) {
    d->paragraphStyleCombo->setCurrentIndex(paraIndex);
}
```

**优化方案**：
提取公共的下拉框更新方法：

```cpp
// ========== RibbonBar.h 新增 ==========
private:
    void updateComboBox(QComboBox* combo, const QString& text);
    void refreshComboBox(QComboBox* combo, const QStringList& items);
```

```cpp
// ========== RibbonBar.cpp 新增 ==========

/**
 * @brief 更新下拉框选择
 * @param combo 下拉框
 * @param text 要选择的文本
 */
void RibbonBar::updateComboBox(QComboBox* combo, const QString& text)
{
    QSignalBlocker blocker(combo);
    int index = combo->findText(text);
    if (index >= 0) {
        combo->setCurrentIndex(index);
    } else {
        combo->setCurrentIndex(-1);
    }
}

/**
 * @brief 刷新下拉框列表
 * @param combo 下拉框
 * @param items 新的选项列表
 */
void RibbonBar::refreshComboBox(QComboBox* combo, const QStringList& items)
{
    QString currentText = combo->currentText();
    QSignalBlocker blocker(combo);
    combo->clear();
    combo->addItems(items);
    int index = combo->findText(currentText);
    if (index >= 0) {
        combo->setCurrentIndex(index);
    }
}
```

```cpp
// ========== 使用示例 ==========

void RibbonBar::updateFromSelection(const QString &characterStyleName,
                                    const QString &paragraphStyleName)
{
    updateComboBox(d->paragraphStyleCombo, paragraphStyleName);
    updateComboBox(d->characterStyleCombo, characterStyleName);
}

void RibbonBar::refreshStyleLists()
{
    if (!d->styleManager)
        return;
    
    refreshComboBox(d->paragraphStyleCombo, d->styleManager->paragraphStyleNames());
    refreshComboBox(d->characterStyleCombo, d->styleManager->characterStyleNames());
}
```

**预期收益**：
- 减少代码行数：约 40 行 → 15 行（减少 63%）
- 统一下拉框操作逻辑

---

## 第六阶段：通用优化（低优先级）

### 问题 20：日志系统统一

**文件**：整个项目

**当前状态**：
代码中分散使用 `qDebug()`、`qInfo()`、`qWarning()`、`qCritical()`，没有统一的日志管理。

**优化方案**：
实施问题 6 中提出的统一日志系统，将所有调试输出替换为 `LOG_DEBUG`、`LOG_INFO`、`LOG_WARNING`、`LOG_ERROR` 宏。

**预期收益**：
- 统一日志格式
- 便于控制日志级别
- 生产环境零调试输出开销

---

### 问题 21：常量定义优化

**文件**：`Constants.h`（可能需要创建）

**当前状态**：
代码中分散使用魔法数字和字符串，如：
- 按钮尺寸：32, 24, 45
- 字体大小：9, 10, 12
- 边距：4, 5, 6, 20

**优化方案**：
创建统一的常量定义文件：

```cpp
// ========== core/utils/Constants.h ==========
#ifndef CONSTANTS_H
#define CONSTANTS_H

#include <QString>

namespace QtWordEditor {
namespace Constants {

// ========== UI 尺寸 ==========
constexpr int RIBBON_BAR_HEIGHT = 120;
constexpr int BUTTON_MIN_WIDTH = 32;
constexpr int BUTTON_MAX_WIDTH = 45;
constexpr int BUTTON_HEIGHT = 24;
constexpr int COMBO_BOX_HEIGHT = 24;
constexpr int LABEL_HEIGHT = 16;

// ========== 字体 ==========
constexpr int DEFAULT_FONT_SIZE = 12;
constexpr int DEBUG_CONSOLE_FONT_SIZE = 9;
constexpr int STATUS_BAR_FONT_SIZE = 10;

// ========== 边距和间距 ==========
constexpr int TAB_LAYOUT_MARGIN = 6;
constexpr int TAB_LAYOUT_SPACING = 20;
constexpr int GROUP_LAYOUT_MARGIN = 0;
constexpr int GROUP_LAYOUT_SPACING = 3;
constexpr int DOCK_WIDGET_MARGIN = 4;
constexpr int STATUS_BAR_MARGIN = 5;
constexpr int STATUS_BAR_SPACING = 2;

// ========== 页面 ==========
constexpr qreal PAGE_WIDTH = 210.0;  // A4 宽度（mm）
constexpr qreal PAGE_HEIGHT = 297.0; // A4 高度（mm）
constexpr qreal PAGE_MARGIN = 25.4;   // 1 英寸（mm）
constexpr qreal PAGE_TOP_SPACING = 30.0;
constexpr qreal PAGE_SPACING = 30.0;

// ========== 其他 ==========
constexpr int DEBUG_CONSOLE_MAX_BLOCKS = 1000;
constexpr double CURSOR_HEIGHT_FACTOR = 1.2;

} // namespace Constants
} // namespace QtWordEditor

#endif // CONSTANTS_H
```

**预期收益**：
- 避免魔法数字
- 便于统一调整 UI 尺寸
- 提高代码可读性

---

## 具体优化实施步骤

### 阶段 1：FormatController 优化（高优先级，预计 3 小时）

1. **添加头文件依赖**
   - 在 `FormatController.h` 中添加 `#include <functional>`

2. **实现 collectSelectionStyles()**
   - 提取跨块 Span 收集逻辑

3. **实现 checkSelectionAll()**
   - 实现通用属性检查方法

4. **简化 isSelectionAllXxx()**
   - 使用新的辅助方法

5. **实现 applySingleProperty()**
   - 提取通用样式设置逻辑

6. **简化所有 setXxx() 方法**
   - 使用新的辅助方法

7. **重构 getSelectionStyleConsistency()**
   - 复用 collectSelectionStyles()

8. **实现 validateSelection()**（可选）
   - 提取选区验证逻辑

9. **实现 applySingleParagraphProperty()**
   - 提取通用段落属性设置逻辑

10. **简化段落样式设置方法**
    - 使用新的辅助方法

### 阶段 2：MainWindow 优化（高优先级，预计 2 小时）

1. **添加头文件依赖**
   - 在 `MainWindow.h` 中添加 `#include <functional>`

2. **实现 toggleStyleAttribute()**
   - 提取通用样式切换逻辑

3. **替换三个 Lambda 连接**
   - 使用新的辅助方法

4. **实现 applyFontProperty()**
   - 提取字体属性应用逻辑

5. **替换字体字号信号处理**
   - 使用新的辅助方法

6. **实现 onStyleChanged()**
   - 提取样式变化处理逻辑

7. **替换样式管理器信号连接**
   - 使用新的槽函数

### 阶段 3：日志系统优化（中优先级，预计 1 小时）

1. **创建 Logger.h 和 Logger.cpp**
   - 实现统一的日志系统

2. **替换所有 qDebug() 调用**
   - 在 MainWindow.cpp、FormatController.cpp、ParagraphBlock.cpp、RibbonBar.cpp 中

### 阶段 4：ParagraphBlock 优化（中优先级，预计 0.5 小时）

1. **实现 validatePositionAndLength()**
   - 提取参数验证逻辑

2. **简化 setStyle() 和 remove()**
   - 使用新的辅助方法

### 阶段 5：RibbonBar 优化（低优先级，预计 2 小时）

1. **实现 createStyleAction()**
   - 提取样式按钮创建逻辑

2. **实现 createAlignmentAction()**
   - 提取对齐按钮创建逻辑

3. **替换按钮创建代码**
   - 使用新的辅助方法

4. **实现 updateStyleProperty()、updateFontCombo()、updateAction()**
   - 提取属性更新逻辑

5. **简化 updateFromSelection()**
   - 使用新的辅助方法

6. **实现 updateComboBox()、refreshComboBox()**
   - 提取下拉框操作逻辑

7. **简化 updateFromSelection() 和 refreshStyleLists()**
   - 使用新的辅助方法

### 阶段 6：通用优化（低优先级，预计 1 小时）

1. **创建或完善 Constants.h**
   - 定义所有常量

2. **替换魔法数字**
   - 在整个项目中使用常量

---

## 预期收益

### 代码行数减少

| 文件 | 优化前 | 优化后 | 减少 | 减少比例 |
|------|--------|--------|------|----------|
| FormatController.cpp | ~400 行 | ~150 行 | 250 行 | 63% |
| MainWindow.cpp | ~150 行 | ~50 行 | 100 行 | 67% |
| ParagraphBlock.cpp | ~60 行(调试) | ~10 行 | 50 行 | 83% |
| RibbonBar.cpp | ~150 行 | ~60 行 | 90 行 | 60% |
| **总计** | **~760 行** | **~270 行** | **~490 行** | **~64%** |

### 可维护性提升

| 方面 | 提升 |
|------|------|
| 新增样式属性 | 从 100+ 行 → 10 行 |
| 新增样式按钮 | 从 40 行 → 4 行 |
| 修改公共逻辑 | 只需修改 1 处 |
| 代码一致性 | 所有方法使用相同模式 |
| 日志管理 | 统一的日志系统 |

### 性能提升

| 方面 | 提升 |
|------|------|
| 调试输出 | 生产环境零开销 |
| 重复计算 | 相同逻辑只执行一次 |
| 代码大小 | 可执行文件更小 |
| 内存使用 | 减少重复代码的内存占用 |

---

---

## 第七阶段：深入优化分析（新增）

### 问题 22：FormatController 中 getCurrentXxx 方法重复

**文件**：`FormatController.cpp`

**当前状态**：
- `getCurrentCharacterStyle()` (第 299-322 行)
- `getCurrentParagraphStyle()` (第 299-322 行)
- `getStyleAtPosition()` (第 324-346 行)

**问题描述**：
这些方法都有相似的模式：检查 m_document、检查 block、转换为 ParagraphBlock、验证偏移量。

**代码片段**：
```cpp
CharacterStyle FormatController::getStyleAtPosition(int blockIndex, int offset) const
{
    CharacterStyle result;

    if (!m_document)
        return result;

    Block *block = m_document->block(blockIndex);
    if (!block)
        return result;

    ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
    if (!paraBlock)
        return result;

    if (offset >= 0 && offset < paraBlock->length()) {
        result = paraBlock->styleAt(offset);
    }

    return result;
}

ParagraphStyle FormatController::getCurrentParagraphStyle() const
{
    ParagraphStyle result;
    
    if (!m_document || !m_selection)
        return result;
    
    SelectionRange range = m_selection->range();
    if (range.isEmpty())
        return result;
    
    Block *block = m_document->block(range.startBlock);
    if (!block)
        return result;
    
    ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
    if (!paraBlock)
        return result;
    
    result = paraBlock->paragraphStyle();
    
    return result;
}
```

**优化方案**：
提取公共的 Block 访问辅助方法：

```cpp
// ========== FormatController.h 新增 ==========
private:
    ParagraphBlock* getParagraphBlock(int blockIndex) const;
```

```cpp
// ========== FormatController.cpp 新增 ==========

/**
 * @brief 获取 ParagraphBlock 的辅助方法
 * @param blockIndex 块索引
 * @return ParagraphBlock 指针，如果失败返回 nullptr
 */
ParagraphBlock* FormatController::getParagraphBlock(int blockIndex) const
{
    if (!m_document)
        return nullptr;
    
    Block *block = m_document->block(blockIndex);
    if (!block)
        return nullptr;
    
    return qobject_cast<ParagraphBlock*>(block);
}
```

```cpp
// ========== 简化后的方法 ==========

CharacterStyle FormatController::getStyleAtPosition(int blockIndex, int offset) const
{
    CharacterStyle result;
    
    ParagraphBlock *paraBlock = getParagraphBlock(blockIndex);
    if (paraBlock && offset >= 0 && offset < paraBlock->length()) {
        result = paraBlock->styleAt(offset);
    }
    
    return result;
}

ParagraphStyle FormatController::getCurrentParagraphStyle() const
{
    ParagraphStyle result;
    
    if (!m_document || !m_selection)
        return result;
    
    SelectionRange range = m_selection->range();
    if (range.isEmpty())
        return result;
    
    ParagraphBlock *paraBlock = getParagraphBlock(range.startBlock);
    if (paraBlock) {
        result = paraBlock->paragraphStyle();
    }
    
    return result;
}
```

**预期收益**：
- 减少代码行数：约 30 行 → 10 行（减少 67%）
- 统一 Block 访问逻辑

---

### 问题 23：getSelectionStyleConsistency 中属性比较代码重复

**文件**：`FormatController.cpp`

**当前状态**：
- 第 515-548 行：对每个属性（字体、字号、粗体、斜体、下划线）都有相同的比较逻辑

**问题描述**：
五个属性比较代码完全相同，只是属性访问器不同。

**代码片段**：
```cpp
// 检查字体
if (consistency.fontFamilyConsistent && currentStyle.fontFamily() != firstStyle.fontFamily()) {
    consistency.fontFamilyConsistent = false;
    qDebug() << "  字体不一致：" << firstStyle.fontFamily() << " vs " << currentStyle.fontFamily();
}

// 检查字号
if (consistency.fontSizeConsistent && currentStyle.fontSize() != firstStyle.fontSize()) {
    consistency.fontSizeConsistent = false;
    qDebug() << "  字号不一致：" << firstStyle.fontSize() << " vs " << currentStyle.fontSize();
}

// 检查粗体
if (consistency.boldConsistent && currentStyle.bold() != firstStyle.bold()) {
    consistency.boldConsistent = false;
    qDebug() << "  粗体不一致：" << firstStyle.bold() << " vs " << currentStyle.bold();
}

// ... 斜体、下划线类似 ...
```

**优化方案**：
使用模板方法或 Lambda 提取公共比较逻辑：

```cpp
// ========== FormatController.h 新增 ==========
private:
    template<typename T>
    void checkStylePropertyConsistency(
        bool& consistencyFlag,
        T& consistentValue,
        const T& firstValue,
        const T& currentValue,
        const QString& propertyName);
```

```cpp
// ========== FormatController.cpp 新增 ==========

/**
 * @brief 检查样式属性一致性的通用方法
 * @param consistencyFlag 一致性标志（引用，会被修改）
 * @param consistentValue 一致时的值（引用，会被修改）
 * @param firstValue 第一个样式的属性值
 * @param currentValue 当前样式的属性值
 * @param propertyName 属性名称（用于调试）
 */
template<typename T>
void FormatController::checkStylePropertyConsistency(
    bool& consistencyFlag,
    T& consistentValue,
    const T& firstValue,
    const T& currentValue,
    const QString& propertyName)
{
    if (consistencyFlag && currentValue != firstValue) {
        consistencyFlag = false;
        LOG_DEBUG(QString("  %1不一致：%2 vs %3").arg(propertyName).arg(firstValue).arg(currentValue));
    }
}
```

```cpp
// ========== 使用示例 ==========

// 在 getSelectionStyleConsistency() 的循环中
checkStylePropertyConsistency<QString>(
    consistency.fontFamilyConsistent,
    consistency.consistentFontFamily,
    firstStyle.fontFamily(),
    currentStyle.fontFamily(),
    "字体"
);

checkStylePropertyConsistency<int>(
    consistency.fontSizeConsistent,
    consistency.consistentFontSize,
    firstStyle.fontSize(),
    currentStyle.fontSize(),
    "字号"
);

checkStylePropertyConsistency<bool>(
    consistency.boldConsistent,
    consistency.consistentBold,
    firstStyle.bold(),
    currentStyle.bold(),
    "粗体"
);

checkStylePropertyConsistency<bool>(
    consistency.italicConsistent,
    consistency.consistentItalic,
    firstStyle.italic(),
    currentStyle.italic(),
    "斜体"
);

checkStylePropertyConsistency<bool>(
    consistency.underlineConsistent,
    consistency.consistentUnderline,
    firstStyle.underline(),
    currentStyle.underline(),
    "下划线"
);
```

**预期收益**：
- 减少代码行数：约 40 行 → 15 行（减少 63%）
- 统一属性比较逻辑

---

### 问题 24：CharacterStyle 和 ParagraphStyle 合并逻辑重复

**文件**：`CharacterStyle.cpp`、`ParagraphStyle.cpp`

**当前状态**：
- `CharacterStyle::mergeWith()` (第 259-293 行)
- `ParagraphStyle::mergeWith()` (第 220-248 行)

**问题描述**：
两个方法的模式完全相同，都是检查每个属性是否已设置，如果已设置则合并。

**代码片段**：
```cpp
// CharacterStyle::mergeWith()
CharacterStyle CharacterStyle::mergeWith(const CharacterStyle &other) const
{
    CharacterStyle result = *this;
    
    if (other.isPropertySet(CharacterStyleProperty::FontFamily)) {
        result.setFontFamily(other.fontFamily());
    }
    if (other.isPropertySet(CharacterStyleProperty::FontSize)) {
        result.setFontSize(other.fontSize());
    }
    // ... 更多属性 ...
    return result;
}

// ParagraphStyle::mergeWith()
ParagraphStyle ParagraphStyle::mergeWith(const ParagraphStyle &other) const
{
    ParagraphStyle result = *this;
    
    if (other.isPropertySet(ParagraphStyleProperty::Alignment)) {
        result.setAlignment(other.alignment());
    }
    if (other.isPropertySet(ParagraphStyleProperty::FirstLineIndent)) {
        result.setFirstLineIndent(other.firstLineIndent());
    }
    // ... 更多属性 ...
    return result;
}
```

**分析**：
这个重复是合理的，因为两个类处理的属性完全不同，过度抽象反而会降低可读性。

**建议**：
保持现状。

---

### 问题 25：RibbonBar 中 QSignalBlocker 创建重复

**文件**：`RibbonBar.cpp`

**当前状态**：
- 第 342-347 行：`updateFromSelection(const CharacterStyle&, bool)`
- 第 411-416 行：`updateFromSelection(const CharacterStyle&, const StyleConsistency&)`

**问题描述**：
两个方法都创建了相同的 QSignalBlocker 列表。

**代码片段**：
```cpp
// 在两个方法中都有
QSignalBlocker fontBlocker(d->fontCombo);
QSignalBlocker fontSizeBlocker(d->fontSizeCombo);
QSignalBlocker boldBlocker(d->boldAction);
QSignalBlocker italicBlocker(d->italicAction);
QSignalBlocker underlineBlocker(d->underlineAction);
```

**优化方案**：
这个重复是必要的，因为 QSignalBlocker 是 RAII 模式，必须在作用域内创建。

**建议**：
保持现状。

---

### 问题 26：ParagraphBlock 中 Span 调试输出重复

**文件**：`ParagraphBlock.cpp`

**当前状态**：
- 第 264-274 行：mergeAdjacentSpans 前后都有遍历输出 spans 的代码

**问题描述**：
```cpp
qDebug() << "  mergeAdjacentSpans 之前的 spans:";
for (int i = 0; i < m_spans.size(); ++i) {
    qDebug() << "    span " << i << ": text=[" << m_spans[i].text() << "], 加粗:" << m_spans[i].style().bold();
}

mergeAdjacentSpans();

qDebug() << "  mergeAdjacentSpans 之后的 spans:";
for (int i = 0; i < m_spans.size(); ++i) {
    qDebug() << "    span " << i << ": text=[" << m_spans[i].text() << "], 加粗:" << m_spans[i].style().bold();
}
```

**优化方案**：
提取辅助方法输出 Span 列表：

```cpp
// ========== ParagraphBlock.h 新增 ==========
private:
    void debugPrintSpans(const QString& title) const;
```

```cpp
// ========== ParagraphBlock.cpp 新增 ==========

void ParagraphBlock::debugPrintSpans(const QString& title) const
{
#ifdef QT_DEBUG
    LOG_DEBUG(title);
    for (int i = 0; i < m_spans.size(); ++i) {
        LOG_DEBUG(QString("    span %1: text=[%2], 加粗:%3")
            .arg(i)
            .arg(m_spans[i].text())
            .arg(m_spans[i].style().bold()));
    }
#endif
}
```

```cpp
// ========== 使用示例 ==========

debugPrintSpans("  mergeAdjacentSpans 之前的 spans:");
mergeAdjacentSpans();
debugPrintSpans("  mergeAdjacentSpans 之后的 spans:");
```

**预期收益**：
- 减少代码重复
- 便于统一管理调试输出

---

## 总结（更新）

通过以上 **26 个优化点**的实施，可以：

1. **减少约 64% 的代码**（760 行 → 270 行）
2. **大幅提高代码可维护性**
3. **降低未来修改的复杂度**
4. **统一代码风格和模式**
5. **提高性能（生产环境零调试输出开销）**

### 优化优先级建议

| 优先级 | 问题编号 | 预计时间 | 收益 |
|--------|----------|----------|------|
| 高 | 1, 2, 3, 5, 6 | 3 小时 | 代码减少 60%+ |
| 中 | 4, 7, 8, 9, 10, 11, 13, 14, 15, 16, 20, 21, 22, 23, 26 | 4 小时 | 可维护性提升 |
| 低 | 12, 17, 18, 19, 24, 25 | 2 小时 | 代码整洁度提升 |

### 关键优化点

1. **FormatController** - 样式一致性检查和设置方法的统一
2. **MainWindow** - 样式按钮点击处理的统一
3. **日志系统** - 统一的日志管理
4. **RibbonBar** - UI 控件更新逻辑的统一
5. **常量定义** - 避免魔法数字

---

**文档版本**：v4.0  
**最后更新**：2026-02-20