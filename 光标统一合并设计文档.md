# 光标统一合并设计文档

---

## 1. 项目概述

### 1.1 目标
将现有的两个光标（普通文档光标 + 数学公式光标）完全合并成一个统一的光标系统，解决两个光标同时出现的问题，简化代码架构。

### 1.2 问题背景
当前系统中存在两套独立的光标实现：
1. **普通文档光标**：由 `Cursor`（业务逻辑）+ `CursorItem`（视觉）组成
2. **数学公式光标**：由 `MathCursor`（业务逻辑 + 视觉）组成
3. **问题**：两套独立的光标管理导致两个光标可能同时出现，增加了代码复杂度和维护成本

---

## 2. 当前架构分析

### 2.1 组件关系图

```
┌─────────────────────────────────────────────────────────────┐
│                        文档编辑系统                         │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────────┐     ┌──────────────────────┐   │
│  │     Cursor (业务)    │     │   MathCursor (业务+  │   │
│  │  - 块索引            │     │   视觉)              │   │
│  │  - 偏移量            │     │  - 容器模式           │   │
│  │  - 公式位置信息      │     │  - 数字模式           │   │
│  └──────────┬───────────┘     └──────────┬───────────┘   │
│             │                             │               │
│             ▼                             ▼               │
│  ┌──────────────────────┐     ┌──────────────────────┐   │
│  │   CursorItem (视觉)  │     │  QGraphicsItem (继承)│   │
│  │  - 闪烁垂直线        │     │  - 闪烁垂直线         │   │
│  │  - 可见性控制        │     │  - 可见性控制         │   │
│  └──────────────────────┘     └──────────────────────┘   │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 现有三个核心组件详细分析

#### 2.2.1 Cursor (业务逻辑层)
**文件位置**：`include/editcontrol/cursor/Cursor.h`

**职责**：
- 管理文档光标位置（块索引 + 偏移量）
- 提供光标移动方法（左、右、上、下、行首、行尾等）
- 提供编辑操作（插入文本、删除字符）
- 发送位置变化信号

**关键数据结构**：
```cpp
struct CursorPosition {
    int blockIndex = -1;           // 块索引
    int offset = 0;                 // 块内偏移量
    
    // 公式内部位置信息
    bool inMathSpan = false;        // 是否在公式内部
    InlineSpan *mathSpan = nullptr; // 当前公式元素
    int mathChildIndex = -1;        // 在公式容器中的子索引
    int mathChildOffset = 0;         // 在公式子元素内的偏移
};
```

**特点**：
- ✅ 已内置公式支持字段
- ✅ 完整的文档光标业务逻辑
- ❌ 没有公式内部导航逻辑

---

#### 2.2.2 MathCursor (业务逻辑 + 视觉)
**文件位置**：`include/graphics/formula/MathCursor.h`

**职责**：
- 管理公式内部光标位置
- 提供公式内部导航方法
- 渲染闪烁的视觉光标
- 可见性控制

**两种模式**：
```cpp
enum CursorMode {
    ContainerMode,  // 容器模式（在 RowContainerItem 中）
    NumberMode      // 数字模式（在 NumberItem 中）
};
```

**导航方法**：
- `moveLeft()` - 左移
- `moveRight()` - 右移
- `moveUp()` - 在分数中从分母移到分子
- `moveDown()` - 在分数中从分子移到分母
- `moveToParent()` - 移到父容器

**特点**：
- ✅ 完整的公式内部导航逻辑
- ✅ 自己实现视觉渲染（继承 QGraphicsItem）
- ❌ 业务逻辑与视觉逻辑耦合
- ❌ 与 Cursor 类功能重复

---

#### 2.2.3 CursorItem (纯视觉)
**文件位置**：`include/graphics/items/CursorItem.h`

**职责**：
- 渲染普通文档的闪烁光标
- 可见性控制
- 闪烁控制

**特点**：
- ✅ 纯视觉组件，不包含业务逻辑
- ✅ 继承 QGraphicsLineItem，简单高效
- ❌ 只能在场景坐标中使用，不能作为其他图形项的子项

---

## 3. 新架构设计

### 3.1 设计原则
1. **单一职责**：业务逻辑与视觉逻辑分离
2. **复用**：统一使用一个视觉组件
3. **扩展性**：方便未来添加新的光标模式
4. **向后兼容**：保持现有 API 不变

### 3.2 新架构图

```
┌─────────────────────────────────────────────────────────────┐
│                    统一光标系统（新架构）                    │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │           UnifiedCursor (统一业务逻辑层)              │  │
│  ├──────────────────────────────────────────────────────┤  │
│  │  • 文档模式：块索引 + 偏移量                           │  │
│  │  • 公式模式：MathItem 导航                             │  │
│  │  • 统一的移动、编辑方法                                 │  │
│  │  • 位置变化信号                                         │  │
│  └──────────────────────┬───────────────────────────────┘  │
│                         │                                    │
│                         ▼                                    │
│  ┌──────────────────────────────────────────────────────┐  │
│  │         UnifiedCursorVisual (统一视觉层)              │  │
│  ├──────────────────────────────────────────────────────┤  │
│  │  • 继承 QGraphicsItem                                  │  │
│  │  • 可作为任意项的子项                                   │  │
│  │  • 统一的闪烁、可见性控制                               │  │
│  │  • 动态高度和位置设置                                   │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
│  ┌──────────────────────────────────────────────────────┐  │
│  │              Cursor 模式枚举                           │  │
│  ├──────────────────────────────────────────────────────┤  │
│  │  enum Mode {                                           │  │
│  │      DocumentMode,    // 普通文档模式                  │  │
│  │      MathContainerMode, // 公式容器模式                │  │
│  │      MathNumberMode   // 公式数字模式                  │  │
│  │  };                                                    │  │
│  └──────────────────────────────────────────────────────┘  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## 4. 详细设计

### 4.1 UnifiedCursor (统一业务逻辑层)

#### 4.1.1 头文件设计 (`include/editcontrol/cursor/UnifiedCursor.h`)

```cpp
#ifndef UNIFIEDCURSOR_H
#define UNIFIEDCURSOR_H

#include <QObject>
#include <QPointF>
#include "core/Global.h"
#include "core/document/CharacterStyle.h"
#include "editcontrol/cursor/Cursor.h"

namespace QtWordEditor {

class Document;
class InlineSpan;
class MathItem;
class RowContainerItem;
class NumberItem;

/**
 * @brief 统一光标模式枚举
 */
enum class CursorMode {
    DocumentMode,       // 普通文档模式
    MathContainerMode,  // 公式容器模式
    MathNumberMode      // 公式数字模式
};

/**
 * @brief 统一光标位置结构体
 * 
 * 整合了文档光标和公式光标的位置信息
 */
struct UnifiedCursorPosition {
    // ========== 文档模式字段 ==========
    int blockIndex = -1;
    int offset = 0;
    
    // ========== 公式模式字段 ==========
    bool inMathSpan = false;
    InlineSpan *mathSpan = nullptr;
    MathItem *mathItem = nullptr;
    RowContainerItem *mathContainer = nullptr;
    NumberItem *mathNumberItem = nullptr;
    int mathChildIndex = -1;
    int mathChildOffset = 0;
    
    // ========== 当前模式 ==========
    CursorMode mode = CursorMode::DocumentMode;
    
    bool operator==(const UnifiedCursorPosition &other) const;
    bool operator!=(const UnifiedCursorPosition &other) const;
};

/**
 * @brief 统一光标类
 * 
 * 整合了普通文档光标和数学公式光标的功能
 * 提供统一的光标管理接口
 */
class UnifiedCursor : public QObject
{
    Q_OBJECT
public:
    explicit UnifiedCursor(Document *document, QObject *parent = nullptr);
    ~UnifiedCursor() override;
    
    // ========== 模式切换 ==========
    void setMode(CursorMode mode);
    CursorMode mode() const;
    
    // ========== 位置管理 ==========
    UnifiedCursorPosition position() const;
    void setPosition(const UnifiedCursorPosition &pos);
    
    // ========== 文档模式方法 ==========
    void setDocumentPosition(int blockIndex, int offset);
    void moveLeft();
    void moveRight();
    void moveUp();
    void moveDown();
    void moveToStartOfLine();
    void moveToEndOfLine();
    void moveToStartOfDocument();
    void moveToEndOfDocument();
    void insertText(const QString &text, const CharacterStyle &style);
    void deletePreviousChar();
    void deleteNextChar();
    
    // ========== 公式模式方法 ==========
    void setMathContainerPosition(RowContainerItem *container, int position);
    void setMathNumberPosition(NumberItem *numberItem, int position);
    void mathMoveLeft();
    void mathMoveRight();
    void mathMoveUp();
    void mathMoveDown();
    void mathMoveToParent();
    
    // ========== 退出公式模式 ==========
    void exitMathMode();
    
signals:
    void positionChanged(const UnifiedCursorPosition &pos);
    void modeChanged(CursorMode newMode, CursorMode oldMode);
    
private:
    Document *m_document;
    UnifiedCursorPosition m_position;
};

} // namespace QtWordEditor

#endif // UNIFIEDCURSOR_H
```

---

### 4.2 UnifiedCursorVisual (统一视觉层)

#### 4.2.1 头文件设计 (`include/graphics/items/UnifiedCursorVisual.h`)

```cpp
#ifndef UNIFIEDCURSORVISUAL_H
#define UNIFIEDCURSORVISUAL_H

#include <QGraphicsItem>
#include <QObject>
#include <QTimer>
#include "core/Global.h"

namespace QtWordEditor {

/**
 * @brief 统一光标视觉组件
 * 
 * 提供统一的光标视觉渲染，支持：
 * - 作为任意 QGraphicsItem 的子项
 * - 动态设置高度和位置
 * - 统一的闪烁和可见性控制
 */
class UnifiedCursorVisual : public QObject, public QGraphicsItem
{
    Q_OBJECT
    Q_INTERFACES(QGraphicsItem)
    
public:
    enum { Type = UserType + 2200 };
    
    explicit UnifiedCursorVisual(QGraphicsItem *parent = nullptr);
    ~UnifiedCursorVisual() override;
    
    // ========== 位置和尺寸设置 ==========
    void setPosition(const QPointF &pos, qreal height);
    void setHeight(qreal height);
    
    // ========== 可见性控制 ==========
    void setVisible(bool visible);
    bool isVisible() const;
    
    // ========== 闪烁控制 ==========
    void startBlink();
    void stopBlink();
    
    // ========== Qt 标准接口 ==========
    int type() const override { return Type; }
    QRectF boundingRect() const override;
    void paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget) override;
    
private slots:
    void blink();
    
private:
    qreal m_height;
    bool m_visible;
    bool m_blinkState;
    QTimer *m_blinkTimer;
};

} // namespace QtWordEditor

#endif // UNIFIEDCURSORVISUAL_H
```

---

### 4.3 实现文件设计

#### 4.3.1 UnifiedCursorVisual 实现 (`src/graphics/items/UnifiedCursorVisual.cpp`)

```cpp
#include "graphics/items/UnifiedCursorVisual.h"
#include <QPainter>

namespace QtWordEditor {

UnifiedCursorVisual::UnifiedCursorVisual(QGraphicsItem *parent)
    : QGraphicsItem(parent)
    , m_height(20.0)
    , m_visible(true)
    , m_blinkState(true)
{
    // 创建闪烁定时器，500ms 闪烁一次
    m_blinkTimer = new QTimer(this);
    connect(m_blinkTimer, &QTimer::timeout, this, &UnifiedCursorVisual::blink);
    m_blinkTimer->start(500);
    
    setZValue(100);  // 确保光标在最上层
}

UnifiedCursorVisual::~UnifiedCursorVisual()
{
    if (m_blinkTimer) {
        m_blinkTimer->stop();
    }
}

void UnifiedCursorVisual::setPosition(const QPointF &pos, qreal height)
{
    setPos(pos);
    m_height = height;
    update();
}

void UnifiedCursorVisual::setHeight(qreal height)
{
    m_height = height;
    update();
}

void UnifiedCursorVisual::setVisible(bool visible)
{
    m_visible = visible;
    update();
}

bool UnifiedCursorVisual::isVisible() const
{
    return m_visible;
}

void UnifiedCursorVisual::startBlink()
{
    if (m_blinkTimer) {
        m_blinkTimer->start(500);
    }
    m_blinkState = true;
    update();
}

void UnifiedCursorVisual::stopBlink()
{
    if (m_blinkTimer) {
        m_blinkTimer->stop();
    }
    m_blinkState = true;
    update();
}

QRectF UnifiedCursorVisual::boundingRect() const
{
    return QRectF(0, 0, 2, m_height);
}

void UnifiedCursorVisual::paint(QPainter *painter, const QStyleOptionGraphicsItem *option, QWidget *widget)
{
    Q_UNUSED(option);
    Q_UNUSED(widget);
    
    if (!m_visible || !m_blinkState) {
        return;
    }
    
    // 绘制黑色光标（2px 宽）
    painter->setPen(QPen(Qt::black, 2));
    painter->drawLine(QPointF(1, 0), QPointF(1, m_height));
}

void UnifiedCursorVisual::blink()
{
    m_blinkState = !m_blinkState;
    update();
}

} // namespace QtWordEditor
```

---

## 5. 迁移计划

### 5.1 阶段一：创建新组件（风险低）
1. 创建 `UnifiedCursor.h` 和 `UnifiedCursor.cpp`
2. 创建 `UnifiedCursorVisual.h` 和 `UnifiedCursorVisual.cpp`
3. 编译测试新组件，确保无错误

### 5.2 阶段二：逐步替换（中等风险）
1. 修改 `DocumentScene`，集成 `UnifiedCursorVisual`
2. 修改 `TextBlockItem`，使用新的统一光标系统
3. 保持旧组件不动，确保向后兼容

### 5.3 阶段三：完全替换（高风险）
1. 删除 `MathCursor` 类
2. 删除 `CursorItem` 类（可选，保留用于兼容性）
3. 更新所有使用旧光标的地方
4. 全面测试

---

## 6. 风险评估

| 风险项 | 风险等级 | 缓解措施 |
|--------|---------|---------|
| 功能回归 | 高 | 全面的回归测试，保留旧组件作为备选 |
| 代码改动大 | 高 | 分阶段实施，每阶段充分测试 |
| 引入新 bug | 中 | 代码审查，单元测试 |
| 向后兼容 | 中 | 保留旧 API，提供迁移指南 |

---

## 7. 优缺点分析

### 7.1 优点
1. ✅ **单一光标**：不会再出现两个光标同时显示的问题
2. ✅ **代码简洁**：减少重复代码，降低维护成本
3. ✅ **架构清晰**：业务逻辑与视觉逻辑分离
4. ✅ **扩展性好**：方便未来添加新的光标模式
5. ✅ **统一管理**：所有光标操作集中在一个地方

### 7.2 缺点
1. ❌ **改动大**：需要重构大量代码
2. ❌ **风险高**：可能引入新的 bug
3. ❌ **时间长**：需要较长的开发和测试时间
4. ❌ **兼容性**：需要处理向后兼容问题

---

## 8. 总结与建议

### 8.1 结论
统一光标是**可行的**，并且是**值得的**，可以从根本上解决两个光标同时出现的问题，简化代码架构。

### 8.2 建议
**采用渐进式迁移策略**：
1. 先创建新组件，但不立即替换旧组件
2. 在新功能中使用新组件
3. 逐步迁移旧代码
4. 待稳定后再删除旧组件

这样可以：
- ✅ 降低风险
- ✅ 保持系统稳定
- ✅ 有回退方案
- ✅ 逐步验证新架构

---

**文档版本**：v1.0  
**创建日期**：2026-02-22  
**作者**：AI Assistant
