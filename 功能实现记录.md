# 功能实现记录

## 调试控制台添加复制按钮和初始测试文字
- **日期**: 2026-02-19
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **修改内容**:
  1. 在 `setupDebugConsole()` 函数中添加了复制按钮
  2. 复制按钮功能：如果有选中文字则复制选中内容，否则全选后复制所有内容
  3. 使用 `QHBoxLayout` 将复制按钮和清空按钮横向排列
  4. 在 `newDocument()` 函数中，将初始空段落改为两段测试文字
  5. 第一段："这是第一段测试文字。欢迎使用 QtWordEditor 文字编辑器！"
  6. 第二段："这是第二段测试文字。您可以在这里进行各种文字编辑操作，包括字体样式修改、段落对齐等功能。"
- **影响**: 
  - 调试控制台现在有了复制功能
  - 新打开的文档会自动包含两段测试文字，方便测试

## 去掉选中文本时工具栏显示选中文本样式的功能
- **日期**: 2026-02-19
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **修改内容**:
  1. 在 `updateStyleState()` 函数中添加了检查逻辑
  2. 当检测到有选区时，直接返回，不更新工具栏的样式显示
- **影响**: 当选中文本时，工具栏不会再显示选中文本的样式，保持当前状态不变

## 去掉GPU加速
- **日期**: 2026-02-19
- **修改文件**: `src/graphics/view/DocumentView.cpp`
- **修改内容**:
  1. 移除了 `#include <QOpenGLWidget>` 头文件包含
  2. 移除了创建 `QOpenGLWidget` 并设置为视口的代码
  3. 更新了注释，说明现在使用默认的软件渲染视口
- **影响**: 应用程序现在使用软件渲染而不是GPU加速渲染

## 重新设计工具栏样式显示逻辑（最终方案）
- **日期**: 2026-02-19
- **修改文件**: 
  1. `工具栏样式显示逻辑设计文档.md`
  2. `src/ui/mainwindow/MainWindow.cpp`
- **修改内容**:
  1. **设计文档优化**：
     - 重新整理文档结构，确保内容前后一致
     - 版本更新到 v5.0（最终简化版）
     - 明确三种场景的处理方式
  2. **MainWindow::updateStyleState() 修改**：
     - 移除了"有选区时不更新工具栏"的限制
     - 直接调用 `getCurrentDisplayStyle()` 获取应该显示的样式
     - 该方法内部已处理：
       - 无选区：返回光标前一个字符的样式
       - 有选区：返回选区终点（Focus）前一个字符的样式
- **设计原则**：
  - 无论是否有选区，工具栏都显示选区终点（Focus）前一个字符的样式
  - 当有选区但样式不一致时，工具栏显示和无选区一样的逻辑
  - 不需要实现"三态显示"（部分选中状态）
- **代码验证**：
  - Selection 类已完整支持 anchor/focus 和 focusPosition()
  - FormatController 类已完整支持 getCurrentDisplayStyle() 等方法
  - EditEventHandler 类已在使用 getCurrentInputStyle()
  - RibbonBar 类已支持 updateFromSelection(const CharacterStyle &style)
- **编译状态**：✅ 编译成功
- **影响**：
  - 工具栏现在在所有场景下都能正确显示样式
  - 有选区时会显示选区终点前一个字符的样式
  - 样式不一致时也会正常显示，无需特殊处理

## 当选中文本时隐藏光标
- **日期**: 2026-02-19
- **修改文件**: 
  1. `include/graphics/items/CursorItem.h`
  2. `src/graphics/items/CursorItem.cpp`
  3. `include/graphics/scene/DocumentScene.h`
  4. `src/graphics/scene/DocumentScene.cpp`
  5. `src/ui/mainwindow/MainWindow.cpp`
- **修改内容**:
  1. **CursorItem 类修改**：
     - 添加 `m_cursorEnabled` 变量，跟踪光标是否启用
     - 添加 `setCursorVisible()` 方法：
       - 参数 visible=true：显示光标并开始闪烁
       - 参数 visible=false：隐藏光标并停止闪烁
     - 修改 `toggleBlink()` 方法：只有在 `m_cursorEnabled` 为 true 时才闪烁
  2. **DocumentScene 类修改**：
     - 添加 `setCursorVisible()` 方法，调用 CursorItem 的对应方法
     - 修改 `updateCursor()` 方法：移除强制设置可见的代码
  3. **MainWindow 类修改**：
     - 修改 `EditEventHandler::selectionNeedsUpdate` 信号连接：
       - 无选区时：`m_scene->setCursorVisible(true)` 显示光标
       - 有选区时：`m_scene->setCursorVisible(false)` 隐藏光标
     - 修改 `Selection::selectionChanged` 信号连接：
       - 添加同样的光标可见性控制逻辑
       - 同时保持原有的 `updateStyleState()` 调用
- **编译状态**：✅ 编译成功
- **影响**：
  - 当选中文本时，光标会自动隐藏
  - 当取消选择时，光标会自动显示并恢复闪烁
  - 提升了选中状态下的视觉体验，避免光标与选择区域重叠

## 选区样式不一致时工具栏不显示样式
- **日期**: 2026-02-19
- **修改文件**: 
  1. `include/editcontrol/formatting/FormatController.h`
  2. `src/editcontrol/formatting/FormatController.cpp`
  3. `include/ui/ribbon/RibbonBar.h`
  4. `src/ui/ribbon/RibbonBar.cpp`
  5. `src/ui/mainwindow/MainWindow.cpp`
  6. `include/core/document/ParagraphBlock.h`
  7. `src/core/document/ParagraphBlock.cpp`
- **修改内容**:
  1. **ParagraphBlock 类修改**：
     - 添加 `isRangeSpansMultipleSpans(int start, int end)` 方法：
       - 检查给定范围是否跨多个 Span
       - 只需查找起始和结束位置对应的 Span 索引，然后比较是否相同
       - 返回 true=跨多个Span（样式不一致），false=单个Span（样式一致）
  2. **FormatController 类修改**：
     - 重构 `isSelectionStyleConsistent()` 方法：
       - **优化前**：遍历选区内的所有字符逐个比较样式
       - **优化后**：通过判断选区是否跨多个 Span 来检查样式一致性
       - 因为一个 Span 代表具有统一（相同）样式的文本片段
       - 选区在单个 Span 内 → 样式一致；跨多个 Span → 样式不一致
       - 选区跨越多个块 → 肯定跨多个 Span → 样式不一致
  3. **RibbonBar 类修改**：
     - 添加重载方法 `updateFromSelection(const CharacterStyle &style, bool styleConsistent)`：
       - 参数 `styleConsistent=true`：正常显示样式
       - 参数 `styleConsistent=false`：不显示样式（混合状态）
     - 混合状态下的行为：
       - 字体下拉框：清空选择 `setCurrentIndex(-1)`
       - 字号下拉框：清空 `clear()`
       - 粗体/斜体/下划线按钮：取消选中状态 `setChecked(false)`
     - 原 `updateFromSelection(const CharacterStyle &style)` 方法保持向后兼容，默认调用新方法并传入 `true`
  4. **MainWindow 类修改**：
     - 重写 `updateStyleState()` 方法：
       - 获取显示样式
       - 判断是否有选区
       - 如果有选区，调用 `isSelectionStyleConsistent()` 检查样式一致性
       - 根据结果调用 RibbonBar 的对应方法
- **三种场景的最终行为**：
  | 场景 | 说明 | 工具栏行为 |
  |------|------|-----------|
  | 场景1：无选区 | 只有光标 | 显示光标前一个字符的样式 |
  | 场景2：有选区且样式一致 | 选区内所有字符样式相同 | 显示选区终点前一个字符的样式 |
  | 场景3：有选区但样式不一致 | 选区内有多种不同样式（跨多个Span） | **不显示样式**（混合状态：清空字体、字号，取消按钮选中） |
- **优化效果**：
  - 性能大幅提升：从 O(n) 遍历所有字符，优化为 O(1) 只查找 2 个 Span 索引
  - 代码更简洁：利用 Span 的语义直接判断，无需逐个字符比较
- **编译状态**：✅ 编译成功
- **影响**：
  - 当选择的文本包含多种样式时，工具栏不会显示任何样式
  - 符合常见文字编辑器（如 Microsoft Word）的行为
  - 用户界面更加清晰直观

## 修复无选区时光标前字符样式不显示的问题
- **日期**: 2026-02-19
- **修改文件**: 
  1. `src/core/document/CharacterStyle.cpp`
  2. `src/ui/ribbon/RibbonBar.cpp`
  3. `src/editcontrol/formatting/FormatController.cpp`
- **问题原因**:
  1. **默认字体硬编码**：CharacterStyle 默认构造函数硬编码为 "Times New Roman"，在 Windows 上可能与 QFontComboBox 中的实际字体名称不匹配
  2. **文档开头返回空样式**：当光标在文档开头（无字符时），getCurrentDisplayStyle() 返回空样式而不是默认样式
  3. **字体设置方法不可靠**：直接使用 QFontComboBox::setCurrentFont() 可能匹配失败，因为它比较的是完整的 QFont 对象（包括粗细、样式等）
- **修改内容**:
  1. **CharacterStyle 类修改**：
     - 默认构造函数使用 `QFont()` 系统默认字体，而不是硬编码 "Times New Roman"
     - 确保默认字号为 12 号
     - clearProperty() 方法中 FontFamily 也改为使用系统默认字体族
  2. **FormatController 类修改**：
     - getCurrentDisplayStyle() 中，当光标在文档开头时，返回 `CharacterStyle()` 默认样式而不是空样式
  3. **RibbonBar 类修改**：
     - updateFromSelection() 中优化字体设置逻辑：
       - 方法1：优先通过字体族名称在下拉框中查找匹配项并设置索引（更可靠）
       - 方法2：如果找不到，再使用 setCurrentFont() 作为备选方案
- **编译状态**：✅ 编译成功
- **影响**：
  - 无选区时，工具栏现在能正确显示光标前一个字符的样式（特别是字体）
  - 字体匹配更可靠，使用系统默认字体避免了硬编码问题
  - 文档开头也能正确显示默认样式

## 修改跨Span选区时工具栏行为：显示最后一个选中字符的样式
- **日期**: 2026-02-19
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **修改前行为**：当选择跨多个 Span（样式不一致）时，工具栏不显示任何样式（混合状态）
- **修改后行为**：无论选择是否跨多个 Span，工具栏始终显示最后一个选中字符的样式
- **修改内容**:
  - 简化 `MainWindow::updateStyleState()` 方法
  - 移除样式一致性检查和混合状态逻辑
  - 始终调用 `m_ribbonBar->updateFromSelection(style, true)` 正常显示样式
  - `getCurrentDisplayStyle()` 本身已经返回：
    - 无选区：光标前一个字符的样式
    - 有选区：选区终点（Focus）前一个字符的样式（即最后一个选中字符的样式）
- **编译状态**：✅ 编译成功
- **影响**：
  - 跨多个 Span 选择时，工具栏现在显示最后一个选中字符的样式
  - 行为更简洁直观，符合用户期望

## 修正选区最后字符位置的计算逻辑
- **日期**: 2026-02-19
- **修改文件**: `src/editcontrol/formatting/FormatController.cpp`
- **问题原因**: 原代码使用 focus 位置（依赖选择方向）来确定最后一个字符，与选区内实际最后一个字符不一致
- **修改内容**:
  - 修改 `getCurrentDisplayStyle()` 方法
  - 有选区时，先获取选区范围并归一化
  - 使用归一化后的 `endBlock` 和 `endOffset` 作为选区结束位置
  - 选区内最后一个字符 = `endOffset - 1`（与选择方向无关）
- **编译状态**：✅ 编译成功
- **影响**：
  - 无论用户从左向右还是从右向左选择，工具栏都显示选区内实际最后一个字符的样式
  - 行为更加一致和可靠

## 恢复选择文字时光标显示
- **日期**: 2026-02-19
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **修改前行为**：选择文字时，光标会自动隐藏
- **修改后行为**：选择文字时，光标始终保持显示
- **修改内容**:
  - 修改了两个信号连接中的光标可见性控制：
    1. `EditEventHandler::selectionNeedsUpdate` 信号处理
    2. `Selection::selectionChanged` 信号处理
  - 移除了有选区时隐藏光标的逻辑
  - 统一改为始终调用 `m_scene->setCursorVisible(true)` 显示光标
- **编译状态**：✅ 编译成功
- **影响**：
  - 选择文字时，光标现在始终可见
  - 用户可以同时看到选区和光标位置

## 恢复使用 focus 位置确定最后一个字符
- **日期**: 2026-02-19
- **修改文件**: `src/editcontrol/formatting/FormatController.cpp`
- **修改内容**: 改回使用选区的 focus 位置来确定工具栏显示的字符样式，而不是归一化选区的 end 位置
- **修改原因**: 从左向右选和从右向左选时，用户希望工具栏显示不同的字符样式（依赖于选择方向）
- **编译状态**：✅ 编译成功
- **影响**：
  - 从左向右选择：工具栏显示选区右侧（focus 位置前）的字符样式
  - 从右向左选择：工具栏显示选区左侧（focus 位置前）的字符样式
  - 行为与选择方向一致，符合用户期望

## 根据选区方向确定工具栏显示的字符
- **日期**: 2026-02-19
- **修改文件**: `src/editcontrol/formatting/FormatController.cpp`
- **修改内容**: 
  - 判断选区方向：通过比较 anchor 和 focus 的位置
  - 从左向右选择（anchor < focus）：取 focus-1 位置的字符
  - 从右向左选择（anchor > focus）：取 focus 位置的字符
- **修改原因**: 用户要求从右向左选择时，工具栏显示选区左侧（focus 位置后）的字符样式
- **编译状态**：✅ 编译成功
- **影响**：
  - 从左向右选择：工具栏显示选区右侧最后一个字符的样式
  - 从右向左选择：工具栏显示选区左侧第一个字符的样式

## 修改加粗/斜体/下划线按钮逻辑：根据当前样式进行切换
- **日期**: 2026-02-19
- **修改文件**: 
  - `src/editcontrol/formatting/FormatController.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **修改前行为**: 点击按钮后直接设置为按钮当前状态（true/false），不根据选区内当前样式进行切换
- **修改后行为**: 
  - 点击按钮后根据选区内最后一个字符的当前样式进行切换
  - 有选区时：切换选区内字符的样式
  - 无选区时：切换新输入字符的样式
- **修改内容**:
  1. FormatController：
     - 修改 `setBold()`、`setItalic()`、`setUnderline()` 方法
     - 忽略传入的参数，获取当前显示样式，取反后再应用
  2. MainWindow：
     - 修改 RibbonBar 的信号连接
     - 同样根据当前显示样式进行切换
- **编译状态**：✅ 编译成功
- **影响**：
  - 选中文字后点击加粗，文字会加粗
  - 再次点击加粗，加粗效果会取消
  - 斜体和下划线按钮同样支持切换功能

## 彻底修复加粗/斜体/下划线按钮切换功能（使用 triggered 信号）
- **日期**: 2026-02-19
- **修改文件**: 
  - `include/ui/ribbon/RibbonBar.h`
  - `src/ui/ribbon/RibbonBar.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题根源**: 使用 `toggled` 信号时，按钮状态变化和逻辑切换会造成循环和冲突
- **解决方案**:
  1. 在 RibbonBar 中添加新的无参数信号：`boldTriggered`、`italicTriggered`、`underlineTriggered`
  2. 将按钮连接改为使用 `triggered` 信号，而不是 `toggled` 信号
  3. 在 MainWindow 中连接新的信号，进行样式切换
  4. RibbonBar 中的 `updateFromSelection` 方法已使用 QSignalBlocker，避免更新按钮状态时触发信号
- **编译状态**：✅ 编译成功
- **影响**：
  - 选中文字后点击加粗，文字会加粗
  - 再次点击加粗，加粗效果会取消
  - 斜体和下划线按钮同样支持切换功能
  - 按钮状态与实际样式同步

## 修复加粗/斜体/下划线按钮切换功能
- **日期**: 2026-02-19
- **修改文件**: 
  - `src/editcontrol/formatting/FormatController.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: FormatController 的方法忽略了传入的参数，导致无法正确应用样式
- **解决方案**:
  1. 恢复 FormatController 的原始方法实现，使用传入的参数
  2. 在 MainWindow 中，根据当前显示样式计算出新的状态，再传递给 FormatController
  3. RibbonBar 中已使用 QSignalBlocker 阻止更新按钮状态时触发信号
- **编译状态**：✅ 编译成功
- **影响**：
  - 选中文字后点击加粗，文字会加粗
  - 再次点击加粗，加粗效果会取消
  - 斜体和下划线按钮同样支持切换功能

## 彻底修复加粗/斜体/下划线按钮切换功能（使用 triggered 信号）
- **日期**: 2026-02-19
- **修改文件**: 
  - `include/ui/ribbon/RibbonBar.h`
  - `src/ui/ribbon/RibbonBar.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题根源**: 使用 `toggled` 信号时，按钮状态变化和逻辑切换会造成循环和冲突
- **解决方案**:
  1. 在 RibbonBar 中添加新的无参数信号：`boldTriggered`、`italicTriggered`、`underlineTriggered`
  2. 将按钮连接改为使用 `triggered` 信号，而不是 `toggled` 信号
  3. 在 MainWindow 中连接新的信号，进行样式切换
  4. RibbonBar 中的 `updateFromSelection` 方法已使用 QSignalBlocker，避免更新按钮状态时触发信号
- **编译状态**：✅ 编译成功
- **影响**：
  - 选中文字后点击加粗，文字会加粗
  - 再次点击加粗，加粗效果会取消
  - 斜体和下划线按钮同样支持切换功能
  - 按钮状态与实际样式同步

## 修复从段首开始选择后加粗导致整段都加粗的问题（真正修复）
- **日期**: 2026-02-19 14:40:00
- **修改文件**: 
  - `src/core/document/ParagraphBlock.cpp`
  - `src/editcontrol/handlers/EditEventHandler.cpp`
  - `src/graphics/items/TextBlockItem.cpp`
- **真正的问题根源**: 
  - 在同一个 span 内处理样式时，删除原始 span 之前没有显式保存原始样式的副本
  - 由于某种原因（可能涉及隐式共享或样式合并操作的副作用），原始 span 的样式在处理过程中被污染，导致 after 部分的 span 也被错误地应用了新样式
- **解决方案**:
  1. **同一个 span 内处理修复**：
     - 在删除原始 span 之前，显式保存 `originalStyle = span.style()` 副本
     - 使用 `originalStyle` 创建 before 和 after 部分的 span，而不是直接使用 `span.style()`
     - 添加详细调试输出，跟踪原始样式和合并后样式的值
  2. **跨 span 处理保持一致性**：
     - 将原来的注释从"保存原始样式引用"更新为"保存原始样式的副本！防止隐式共享问题！"
     - 确保两种处理路径（同一个 span 和跨 span）的代码风格一致
  3. **添加更多调试输出**：
     - 在 TextBlockItem::applyRichTextFromBlock 中添加调试，显示每个 span 的加粗状态
     - 在 ParagraphBlock::setStyle 中添加 mergeAdjacentSpans 前后的 spans 状态
     - 在同一个 span 处理中添加原始样式和合并后样式的调试
- **编译状态**：✅ 编译成功
- **验证结果**：
  - `mergeAdjacentSpans 之前的 spans:`
    - `span 0: text=["这是第一段"], 加粗: true`
    - `span 1: text=["测试文字。欢迎使用 QtWordEditor 文字编辑器！"], 加粗: false`
  - `mergeAdjacentSpans 之后的 spans:`
    - `span 0: text=["这是第一段"], 加粗: true`
    - `span 1: text=["测试文字。欢迎使用 QtWordEditor 文字编辑器！"], 加粗: false`
  - ✅ 只有选中范围被加粗，未选中范围保持原样
- **影响**：
  - 从段首开始选择文本后，点击加粗按钮，只会加粗选中的文本，而不会整段都加粗
  - 同一段内的部分选择现在可以正确处理
  - 跨 span 的样式应用也保持正确
  - 添加了完整的调试输出，便于未来问题排查

## 修复单个Span内选择时工具栏样式显示问题，以及跨Span选择显示混合状态
- **日期**: 2026-02-19 15:00:00
- **修改文件**: 
  - `src/editcontrol/formatting/FormatController.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
  - `src/graphics/items/TextBlockItem.cpp`
- **问题原因**: 
  1. **单个Span内选择时工具栏样式显示错误**：当反向选择且选区完全在单个Span内时，代码错误地获取到前一个Span的样式
  2. **缺少样式一致性检查方法**：FormatController的isSelectionStyleConsistent()方法没有实现
  3. **Span边界不清晰**：用户无法直观看到Span的边界和样式
- **解决方案**:
  1. **单个Span内选择修复**：
     - 修改 `getCurrentDisplayStyle()` 方法，优先检查选区是否完全在单个Span内
     - 如果是，直接使用该Span的样式，避免计算位置错误
  2. **实现isSelectionStyleConsistent()**：
     - 检查选区是否跨多个块或多个Span
     - 单个Span内返回true（样式一致），跨多个Span返回false（样式不一致）
  3. **添加Span视觉调试**：
     - 给每个Span添加3种交替颜色的边框和背景
     - 使用HTML格式渲染，确保边框可见
     - 添加调试输出显示选中的Span数量和详情
  4. **MainWindow修改**：
     - 使用isSelectionStyleConsistent()判断样式是否一致
     - 一致时显示样式，不一致时显示混合状态
- **最终行为**:
  | 场景 | 说明 | 工具栏行为 |
  |------|------|-----------|
  | 场景1：无选区 | 只有光标 | 显示光标前一个字符的样式 |
  | 场景2：单个Span内选择 | 选区内所有字符样式相同 | 显示该Span的样式 |
  | 场景3：跨多个Span选择 | 选区内有多种不同样式 | **显示混合状态（空状态） |
- **编译状态**：✅ 编译成功
- **验证结果**:
  - 单个Span内选择，无论选择方向如何，都正确显示该Span样式
  - 跨多个Span选择时，工具栏显示混合状态
  - Span边界通过彩色边框清晰可见
  - 调试输出显示选中的Span数量和详情
- **影响**：
  - 工具栏现在能正确显示单个Span内选择的样式
  - 跨多个Span选择时显示混合状态，符合用户期望
  - 通过彩色边框可以直观调试Span边界

## 分别检查每个样式属性的一致性，而不是整体显示空状态
- **日期**: 2026-02-19 15:15:00
- **修改文件**: 
  - `include/editcontrol/formatting/FormatController.h`
  - `src/editcontrol/formatting/FormatController.cpp`
  - `include/ui/ribbon/RibbonBar.h`
  - `src/ui/ribbon/RibbonBar.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: 
  - 原来的实现是整体判断选区样式是否一致，如果不一致就整体显示空状态
  - 这样不够精细，应该分别检查每个属性（粗体、斜体、下划线、字体、字号）
  - 如果某个属性在所有选中的Span中都一致，就应该显示该属性；如果不一致，就显示混合状态
- **解决方案**:
  1. **FormatController 修改**：
     - 添加 `StyleConsistency` 结构体，分别保存每个属性的一致性状态
     - 实现 `getSelectionStyleConsistency()` 方法，收集所有与选区重叠的Span，逐个比较每个属性
     - 保持 `isSelectionStyleConsistent()` 方法用于向后兼容
  2. **RibbonBar 修改**：
     - 添加同样的 `StyleConsistency` 结构体
     - 实现新的 `updateFromSelection(const CharacterStyle &style, const StyleConsistency &consistency)` 方法
     - 该方法根据每个属性的一致性状态单独处理：
       - 如果一致，显示该属性
       - 如果不一致，显示混合状态（清空/取消选中）
  3. **MainWindow 修改**：
     - 有选区时，先检查是否完全在单个Span内
     - 如果是，直接显示一致样式
     - 如果不是，获取每个属性的一致性状态，然后传递给RibbonBar
- **最终行为**:
  | 场景 | 说明 | 工具栏行为 |
  |------|------|-----------|
  | 无选区 | 只有光标 | 显示光标前一个字符的所有样式 |
  | 单个Span内选择 | 选区内所有字符样式相同 | 显示该Span的所有样式 |
  | 跨多个Span选择，只有粗体不一致 | 选区内粗体有不同，其他都相同 | 粗体显示混合状态，其他都正常显示 |
  | 跨多个Span选择，多个属性不一致 | 多个属性有不同 | 只有不一致的属性显示混合状态 |
- **编译状态**：✅ 代码已修改完成，等待编译测试
- **影响**：
  - 工具栏现在能分别处理每个属性的一致性
  - 只有不一致的属性才会显示混合状态，一致的属性仍然正常显示
  - 行为更加精细和合理

## 优化工具栏更新性能：只在鼠标松开时计算样式
- **日期**: 2026-02-19 15:20:00
- **修改文件**: 
  - `include/editcontrol/handlers/EditEventHandler.h`
  - `src/editcontrol/handlers/EditEventHandler.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: 
  - 原来的实现是在 Selection::selectionChanged 信号时立即更新工具栏样式
  - 当用户拖动鼠标选择时，selectionChanged 会频繁触发，导致大量的样式计算
  - 这会造成卡顿，影响用户体验
- **解决方案**:
  1. **EditEventHandler 修改**：
     - 添加新的信号 `selectionFinished()`，只在鼠标松开时发出
     - 在 `handleMouseRelease()` 方法结束时发出该信号
  2. **MainWindow 修改**：
     - 修改 `Selection::selectionChanged` 信号连接：只更新光标可见性，不更新样式
     - 添加 `Cursor::positionChanged` 信号连接：只有在无选区时才更新样式
     - 添加新的 `EditEventHandler::selectionFinished` 信号连接：只在鼠标松开时才更新工具栏样式
- **最终行为**:
  | 场景 | 工具栏更新时机 |
  |------|----------------|
  | 无选区，光标移动 | 立即更新 |
  | 拖动鼠标选择 | 不更新 |
  | 鼠标松开（选择完成） | 更新 |
- **影响**：
  - 拖动选择时不再有性能问题，不会卡顿
  - 只在选择完成时才计算样式，性能大幅提升
  - 用户体验更好

## 修复跨 Span 选择时工具栏显示和按钮点击问题
- **日期**: 2026-02-19 15:40:00
- **修改文件**: 
  - `src/editcontrol/formatting/FormatController.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
  - `src/graphics/items/TextBlockItem.cpp`
- **问题原因**: 
  1. 跨 Span 选择时，工具栏显示最后一个字符的样式，用户希望显示空状态
  2. 跨 Span 选择时，点击加粗按钮会根据当前显示样式切换，而不是直接设置为加粗
  3. 之前用于调试的彩色边框 HTML 渲染方式可能影响样式显示
- **解决方案**:
  1. **getCurrentDisplayStyle 修改**：
     - 当跨多个 Span 时，直接返回默认空样式（不显示最后一个字符的样式）
     - 保持在单个 Span 内时的正常显示
  2. **MainWindow 按钮逻辑修改**：
     - 有选区时：直接设置为 true（加粗/斜体/下划线），不进行切换
     - 无选区时：保持原来的切换行为（根据当前样式取反）
  3. **TextBlockItem 修改**：
     - 移除调试用的彩色边框，恢复使用 QTextDocument 正确渲染富文本样式
- **最终行为**:
  | 场景 | 工具栏显示 | 点击按钮行为 |
  |------|-----------|------------|
  | 无选区，光标移动 | 显示光标前一个字符样式 | 切换新输入样式 |
  | 单个 Span 内选择 | 显示该 Span 样式 | 直接设置为 true |
  | 跨多个 Span 选择 | 显示空状态 | 直接设置为 true |
- **影响**：
  - 跨 Span 选择时工具栏显示更合理的空状态
  - 点击按钮后选区内所有内容都会正确设置为相应样式
  - 样式渲染更可靠

## 修复按钮切换功能：根据选区内实际状态决定是设置还是取消
- **日期**: 2026-02-19 16:00:00
- **修改文件**: 
  - `include/editcontrol/formatting/FormatController.h`
  - `src/editcontrol/formatting/FormatController.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: 
  1. 当跨多个 Span 时，`getCurrentDisplayStyle()` 返回默认样式，无法正确判断选区内是否全部加粗
  2. 原来的逻辑根据 `getCurrentDisplayStyle()` 来切换，导致跨 Span 选择后再次点击无法取消加粗
- **解决方案**:
  1. **FormatController 新增方法**：
     - `isSelectionAllBold()`：检查选区内所有字符的粗体是否都为 true
     - `isSelectionAllItalic()`：检查选区内所有字符的斜体是否都为 true
     - `isSelectionAllUnderline()`：检查选区内所有字符的下划线是否都为 true
  2. **MainWindow 按钮逻辑修改**：
     - 使用新增的三个方法来判断选区内状态
     - 有选区时，先调用 `isSelectionAllXxx()` 检查
     - 如果选区内全部都是 true（全部加粗/斜体/下划线）→ 则设置为 false（取消）
     - 否则 → 设置为 true（加粗/斜体/下划线）
     - 每次点击都会重新判断，确保状态正确
- **最终行为**:
  | 场景 | 第一次点击 | 第二次点击 |
  |------|-----------|-----------|
  | 无选区 | 切换新输入样式 | 切换新输入样式 |
  | 单个 Span 内选择（未加粗） | 加粗 | 取消加粗 |
  | 跨多个 Span 选择（部分加粗） | 全部加粗 | 取消全部加粗 |
- **影响**：
  - 无论单个 Span 还是跨多个 Span，点击按钮都能正确地在设置和取消之间切换
  - 每次点击都会根据当前选区内状态重新判断
  - 用户体验更加自然

## 修复流程图 Mermaid 语法错误（完全重写）
- **日期**: 2026-02-19 14:30:00
- **修改文件**: `样式按钮点击详细流程图.md`
- **问题原因**: 
  - 在 Mermaid 流程图的节点内容中，特殊符号（如 `||`、`-&gt;`、`.`）会被解析器误解
  - 这些符号与 Mermaid 的连接符和特殊标记冲突，导致解析错误
- **修改内容**:
  1. **完全重写所有流程图**，移除所有可能导致解析错误的特殊符号
  2. 将 `||` 替换为"或"
  3. 将 `-&gt;` 移除，直接用空格分隔方法名和属性
  4. 将 `.` 移除，避免与 Mermaid 语法冲突
  5. 移除所有括号中的方法调用括号 `()`，简化为纯文字描述
- **影响**：
  - 所有流程图现在都符合 Mermaid 语法规范
  - 可以正确解析和显示
  - 保持了原有的流程逻辑完整性

## 创建详细的样式按钮点击流程图文档
- **日期**: 2026-02-19 14:30:00
- **修改文件**: 
  - `样式按钮点击详细流程图.md`（新建）
- **需求原因**: 
  - 原有的设计文档流程图不够详细
  - 用户需要以流程图为主的详细文档，便于理解完整流程
- **解决方案**:
  1. 创建新的流程图文档，全部使用 Mermaid 图表
  2. 包含以下详细流程图：
     - 总体流程图
     - MainWindow 处理流程
     - isSelectionAllBold() 详细流程
     - applyCharacterStyle() 详细流程
     - SetCharacterStyleCommand::redo() 流程
     - ParagraphBlock::setStyle() 详细流程
     - updateStyleState() 流程
     - 完整流程串联图（无选区情况）
     - 完整流程串联图（有选区情况）
     - 关键数据流向图
  3. 每个流程图都详细展示了代码执行的每一个步骤和分支判断
- **影响**：
  - 提供了完整、详细的流程图文档
  - 便于开发人员理解和调试样式按钮点击的完整流程
  - 可作为项目维护的参考文档

## 改进跨 Span 选择时工具栏显示：显示一致的属性
- **日期**: 2026-02-19 16:30:00
- **修改文件**: 
  - `include/editcontrol/formatting/FormatController.h`
  - `src/editcontrol/formatting/FormatController.cpp`
  - `include/ui/ribbon/RibbonBar.h`
  - `src/ui/ribbon/RibbonBar.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: 
  - 原来的跨 Span 选择时，如果某个属性在所有选中的 Span 中都一致，工具栏不应该显示混合状态，而应该显示该属性的值
  - 例如，如果所有选中的 Span 都是粗体，工具栏的粗体按钮应该显示为选中状态
- **解决方案**:
  1. **StyleConsistency 结构体修改**：
     - 添加一致时的属性值字段：`consistentFontFamily`、`consistentFontSize`、`consistentBold`、`consistentItalic`、`consistentUnderline`
     - 在构造函数中初始化这些值
  2. **getSelectionStyleConsistency 方法修改**：
     - 在初始化时，使用第一个 Span 的样式作为基准，记录所有属性的初始值
     - 在比较过程中，如果发现某个属性不一致，就将对应的 `xxxConsistent` 设为 false
     - 但保留第一个 Span 的属性值在 `consistentXxx` 中，供后续使用
  3. **RibbonBar::updateFromSelection 方法修改**：
     - 不再使用传入的 `style` 对象，而是直接使用 `consistency` 结构体中存储的一致属性值
     - 这样可以确保即使跨多个 Span，只要某个属性一致，就正确显示该属性
  4. **MainWindow 修改**：
     - 在将 `FormatController::StyleConsistency` 转换为 `RibbonBar::StyleConsistency` 时，同时传递一致的属性值
- **最终行为**:
  | 场景 | 说明 | 工具栏行为 |
  |------|------|-----------|
  | 所有选中 Span 都是粗体 | 粗体一致，其他属性可能一致或不一致 | 粗体按钮显示为选中 |
  | 所有选中 Span 字号都是 14 | 字号一致，其他属性可能一致或不一致 | 字号显示 14 |
  | 跨多个 Span，粗体不一致，但斜体一致 | 部分属性一致，部分不一致 | 斜体按钮显示为选中，粗体显示混合状态 |
- **影响**：
  - 跨多个 Span 选择时，如果某个属性在所有选中 Span 中都一致，工具栏会正确显示该属性
  - 用户体验更好，符合常见文字编辑器的行为

## 修复工具栏在选择过程中实时更新的问题
- **日期**: 2026-02-19 16:35:00
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: 
  - 在 `MainWindow::updateCursorPosition` 函数中调用了 `updateStyleState()`，而该函数是连接到 `Cursor::positionChanged` 信号的
  - 在选择过程中，`EditEventHandler::handleMouseMove` 会不断调用 `m_cursor->setPosition()`，导致光标位置信号不断触发
  - 这导致工具栏在选择过程中实时更新，而不是只在鼠标松开时更新
- **解决方案**:
  - 移除 `MainWindow::updateCursorPosition` 函数中的 `updateStyleState()` 调用
  - 保持其他连接不变：
    - 无选区时，由单独的 `cursor->positionChanged` 连接处理样式更新
    - 有选区时，只在 `editEventHandler->selectionFinished` 信号（鼠标松开）时更新样式
- **最终行为**:
  | 场景 | 工具栏更新时机 |
  |------|----------------|
  | 无选区，光标移动 | 立即更新 |
  | 拖动鼠标选择 | 不更新 |
  | 鼠标松开（选择完成） | 更新 |
- **影响**：
  - 拖动选择时工具栏不再实时更新，避免了不必要的计算和闪烁
  - 只在选择完成（鼠标松开）时才计算和显示样式，性能提升，用户体验更好

## 修复跨段落选择时的样式一致性检测
- **日期**: 2026-02-19 17:00:00
- **修改文件**: `src/editcontrol/formatting/FormatController.cpp`
- **问题原因**: 
  - `getSelectionStyleConsistency`、`isSelectionAllBold`、`isSelectionAllItalic`、`isSelectionAllUnderline` 方法在跨多个块（段落）选择时，直接返回不一致，不进行实际检查
- **解决方案**:
  1. **getSelectionStyleConsistency 方法修改：
     - 移除了跨块检查，改为遍历从 startBlock 到 endBlock 的所有块
     - 对每个块计算正确的起始和结束偏移量
     - 收集所有与选区重叠的 Span 的样式
  2. **isSelectionAllBold/isSelectionAllItalic/isSelectionAllUnderline 方法修改：
     - 同样支持跨多个块的检查
     - 遍历所有相关块和 Span
- **最终行为**:
  - 跨多个段落选择时，样式一致性检测可以正确工作
  - 工具栏可以正确显示一致的属性
- **影响**：
  - 解决了跨段落选择时工具栏显示错误的问题

## 修复字体设置问题
- **日期**: 2026-02-19 17:10:00
- **修改文件**: `src/core/document/CharacterStyle.cpp`
- **问题原因**: 
  - `CharacterStyle::setFont()` 方法在设置字体时，设置了所有字体相关属性标记（包括粗体、斜体、下划线等）
  - 这导致在只改变字体族或字号时，会意外改变其他样式属性
- **解决方案**:
  - 修改 `CharacterStyle::setFont()` 方法，只在字体族或字号变化时设置对应的属性标记
  - 不再设置粗体、斜体、下划线、删除线等属性标记
  - 这些属性只在专门调用 `setBold()`、`setItalic()` 等方法时才设置
- **最终行为**:
  - 改变字体族或字号时，不会改变粗体、斜体等其他样式属性
- **影响**：
  - 解决了字体设置不正确的问题

## 修复文本渲染不显示字体和字号的问题
- **日期**: 2026-02-19 17:20:00
- **修改文件**: `src/graphics/items/TextBlockItem.cpp`
- **问题原因**: 
  - `TextBlockItem::applyRichTextFromBlock()` 方法在生成 HTML 时，只处理了粗体、斜体、下划线三种样式
  - 完全没有处理字体族和字号，导致这些样式无法显示
- **解决方案**:
  - 在 span 的 style 属性中加入：
    - `font-family`：字体族
    - `font-size`：字号
  - 保持使用 HTML 标签 `<b>`、`<i>`、`<u>` 处理粗体、斜体、下划线（更可靠）
- **最终行为**:
  - 文本渲染可以正确显示字体族、字号、粗体、斜体、下划线了
- **影响**：
  - 解决了字体和字号设置后不显示的问题

## 修复修改字体时字号也被改变的问题
- **日期**: 2026-02-19 17:30:00
- **修改文件**: 
  - `src/ui/mainwindow/MainWindow.cpp`
  - `include/editcontrol/formatting/FormatController.h`
  - `src/editcontrol/formatting/FormatController.cpp`
- **问题原因**: 
  - 当用户从字体下拉框选择字体时，传递了完整的 QFont 对象，这个对象包含了字号信息
  - 导致修改字体时，字号也被意外改变
- **解决方案**:
  1. 在 MainWindow 中，处理 `fontChanged` 信号时，只提取字体族，不使用完整的 QFont
  2. 在 FormatController 中新增 `setFontFamily(const QString &family)` 方法，专门用于只设置字体族
- **最终行为**:
  - 修改字体时，只改变字体族，不改变字号
- **影响**：
  - 解决了修改字体时字号被改变的问题

## 修改字号控件为 QComboBox 并支持常见字号选项
- **日期**: 2026-02-19 17:40:00
- **修改文件**: 
  - `include/ui/ribbon/RibbonBar.h`
  - `src/ui/ribbon/RibbonBar.cpp`
- **问题原因**: 
  - 原字号控件使用 QSpinBox，不够直观
- **解决方案**:
  1. 将字号控件从 QSpinBox 改为 QComboBox
  2. 添加常见字号选项（6, 7, 8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72）
  3. 设置为可编辑，支持用户自定义输入字号
  4. 修改所有使用 fontSizeSpin 的地方为 fontSizeCombo
- **最终行为**:
  - 字号控件变为下拉框，包含常见字号选项
  - 支持用户手动输入自定义字号
- **影响**：
  - 提供了更直观的字号选择体验

## 实现光标大小随字号自动变化
- **日期**: 2026-02-19 17:40:00
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: 
  - 光标高度固定为 20.0，字号变大或变小时，光标大小不会相应变化
- **解决方案**:
  1. 在 `updateCursorPosition` 方法中，获取光标位置所在的块
  2. 使用 `ParagraphBlock::styleAt()` 方法获取该位置的字符样式
  3. 根据字号计算合适的光标高度（字号 * 1.2）
- **最终行为**:
  - 光标高度会根据当前位置的字号自动调整
  - 字号越大，光标越高；字号越小，光标越矮
- **影响**：
  - 提供了更好的视觉反馈，光标高度与文字大小相匹配
