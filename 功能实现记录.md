# 功能实现记录

## 调试控制台添加复制按钮和初始测试文字
- **日期**: 2026-02-19
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **修改内容**:
  1. 在 `setupDebugConsole()` 函数中添加了复制按钮
  2. 复制按钮功能：如果有选中文字则复制选中内容，否则全选后复制所有内容
  3. 使用 `QHBoxLayout` 将复制按钮和清空按钮横向排列
  4. 在 `newDocument()` 函数中，将初始空段落改为两段测试文字
  5. 第一段："这是第一段测试文字。欢迎使用 QtWordEditor 文字编辑器！"
  6. 第二段："这是第二段测试文字。您可以在这里进行各种文字编辑操作，包括字体样式修改、段落对齐等功能。"
- **影响**: 
  - 调试控制台现在有了复制功能
  - 新打开的文档会自动包含两段测试文字，方便测试

## 去掉选中文本时工具栏显示选中文本样式的功能
- **日期**: 2026-02-19
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **修改内容**:
  1. 在 `updateStyleState()` 函数中添加了检查逻辑
  2. 当检测到有选区时，直接返回，不更新工具栏的样式显示
- **影响**: 当选中文本时，工具栏不会再显示选中文本的样式，保持当前状态不变

## 去掉GPU加速
- **日期**: 2026-02-19
- **修改文件**: `src/graphics/view/DocumentView.cpp`
- **修改内容**:
  1. 移除了 `#include <QOpenGLWidget>` 头文件包含
  2. 移除了创建 `QOpenGLWidget` 并设置为视口的代码
  3. 更新了注释，说明现在使用默认的软件渲染视口
- **影响**: 应用程序现在使用软件渲染而不是GPU加速渲染

## 重新设计工具栏样式显示逻辑（最终方案）
- **日期**: 2026-02-19
- **修改文件**: 
  1. `工具栏样式显示逻辑设计文档.md`
  2. `src/ui/mainwindow/MainWindow.cpp`
- **修改内容**:
  1. **设计文档优化**：
     - 重新整理文档结构，确保内容前后一致
     - 版本更新到 v5.0（最终简化版）
     - 明确三种场景的处理方式
  2. **MainWindow::updateStyleState() 修改**：
     - 移除了"有选区时不更新工具栏"的限制
     - 直接调用 `getCurrentDisplayStyle()` 获取应该显示的样式
     - 该方法内部已处理：
       - 无选区：返回光标前一个字符的样式
       - 有选区：返回选区终点（Focus）前一个字符的样式
- **设计原则**：
  - 无论是否有选区，工具栏都显示选区终点（Focus）前一个字符的样式
  - 当有选区但样式不一致时，工具栏显示和无选区一样的逻辑
  - 不需要实现"三态显示"（部分选中状态）
- **代码验证**：
  - Selection 类已完整支持 anchor/focus 和 focusPosition()
  - FormatController 类已完整支持 getCurrentDisplayStyle() 等方法
  - EditEventHandler 类已在使用 getCurrentInputStyle()
  - RibbonBar 类已支持 updateFromSelection(const CharacterStyle &style)
- **编译状态**：✅ 编译成功
- **影响**：
  - 工具栏现在在所有场景下都能正确显示样式
  - 有选区时会显示选区终点前一个字符的样式
  - 样式不一致时也会正常显示，无需特殊处理

## 当选中文本时隐藏光标
- **日期**: 2026-02-19
- **修改文件**: 
  1. `include/graphics/items/CursorItem.h`
  2. `src/graphics/items/CursorItem.cpp`
  3. `include/graphics/scene/DocumentScene.h`
  4. `src/graphics/scene/DocumentScene.cpp`
  5. `src/ui/mainwindow/MainWindow.cpp`
- **修改内容**:
  1. **CursorItem 类修改**：
     - 添加 `m_cursorEnabled` 变量，跟踪光标是否启用
     - 添加 `setCursorVisible()` 方法：
       - 参数 visible=true：显示光标并开始闪烁
       - 参数 visible=false：隐藏光标并停止闪烁
     - 修改 `toggleBlink()` 方法：只有在 `m_cursorEnabled` 为 true 时才闪烁
  2. **DocumentScene 类修改**：
     - 添加 `setCursorVisible()` 方法，调用 CursorItem 的对应方法
     - 修改 `updateCursor()` 方法：移除强制设置可见的代码
  3. **MainWindow 类修改**：
     - 修改 `EditEventHandler::selectionNeedsUpdate` 信号连接：
       - 无选区时：`m_scene->setCursorVisible(true)` 显示光标
       - 有选区时：`m_scene->setCursorVisible(false)` 隐藏光标
     - 修改 `Selection::selectionChanged` 信号连接：
       - 添加同样的光标可见性控制逻辑
       - 同时保持原有的 `updateStyleState()` 调用
- **编译状态**：✅ 编译成功
- **影响**：
  - 当选中文本时，光标会自动隐藏
  - 当取消选择时，光标会自动显示并恢复闪烁
  - 提升了选中状态下的视觉体验，避免光标与选择区域重叠

## 选区样式不一致时工具栏不显示样式
- **日期**: 2026-02-19
- **修改文件**: 
  1. `include/editcontrol/formatting/FormatController.h`
  2. `src/editcontrol/formatting/FormatController.cpp`
  3. `include/ui/ribbon/RibbonBar.h`
  4. `src/ui/ribbon/RibbonBar.cpp`
  5. `src/ui/mainwindow/MainWindow.cpp`
  6. `include/core/document/ParagraphBlock.h`
  7. `src/core/document/ParagraphBlock.cpp`
- **修改内容**:
  1. **ParagraphBlock 类修改**：
     - 添加 `isRangeSpansMultipleSpans(int start, int end)` 方法：
       - 检查给定范围是否跨多个 Span
       - 只需查找起始和结束位置对应的 Span 索引，然后比较是否相同
       - 返回 true=跨多个Span（样式不一致），false=单个Span（样式一致）
  2. **FormatController 类修改**：
     - 重构 `isSelectionStyleConsistent()` 方法：
       - **优化前**：遍历选区内的所有字符逐个比较样式
       - **优化后**：通过判断选区是否跨多个 Span 来检查样式一致性
       - 因为一个 Span 代表具有统一（相同）样式的文本片段
       - 选区在单个 Span 内 → 样式一致；跨多个 Span → 样式不一致
       - 选区跨越多个块 → 肯定跨多个 Span → 样式不一致
  3. **RibbonBar 类修改**：
     - 添加重载方法 `updateFromSelection(const CharacterStyle &style, bool styleConsistent)`：
       - 参数 `styleConsistent=true`：正常显示样式
       - 参数 `styleConsistent=false`：不显示样式（混合状态）
     - 混合状态下的行为：
       - 字体下拉框：清空选择 `setCurrentIndex(-1)`
       - 字号下拉框：清空 `clear()`
       - 粗体/斜体/下划线按钮：取消选中状态 `setChecked(false)`
     - 原 `updateFromSelection(const CharacterStyle &style)` 方法保持向后兼容，默认调用新方法并传入 `true`
  4. **MainWindow 类修改**：
     - 重写 `updateStyleState()` 方法：
       - 获取显示样式
       - 判断是否有选区
       - 如果有选区，调用 `isSelectionStyleConsistent()` 检查样式一致性
       - 根据结果调用 RibbonBar 的对应方法
- **三种场景的最终行为**：
  | 场景 | 说明 | 工具栏行为 |
  |------|------|-----------|
  | 场景1：无选区 | 只有光标 | 显示光标前一个字符的样式 |
  | 场景2：有选区且样式一致 | 选区内所有字符样式相同 | 显示选区终点前一个字符的样式 |
  | 场景3：有选区但样式不一致 | 选区内有多种不同样式（跨多个Span） | **不显示样式**（混合状态：清空字体、字号，取消按钮选中） |
- **优化效果**：
  - 性能大幅提升：从 O(n) 遍历所有字符，优化为 O(1) 只查找 2 个 Span 索引
  - 代码更简洁：利用 Span 的语义直接判断，无需逐个字符比较
- **编译状态**：✅ 编译成功
- **影响**：
  - 当选择的文本包含多种样式时，工具栏不会显示任何样式
  - 符合常见文字编辑器（如 Microsoft Word）的行为
  - 用户界面更加清晰直观

## 修复无选区时光标前字符样式不显示的问题
- **日期**: 2026-02-19
- **修改文件**: 
  1. `src/core/document/CharacterStyle.cpp`
  2. `src/ui/ribbon/RibbonBar.cpp`
  3. `src/editcontrol/formatting/FormatController.cpp`
- **问题原因**:
  1. **默认字体硬编码**：CharacterStyle 默认构造函数硬编码为 "Times New Roman"，在 Windows 上可能与 QFontComboBox 中的实际字体名称不匹配
  2. **文档开头返回空样式**：当光标在文档开头（无字符时），getCurrentDisplayStyle() 返回空样式而不是默认样式
  3. **字体设置方法不可靠**：直接使用 QFontComboBox::setCurrentFont() 可能匹配失败，因为它比较的是完整的 QFont 对象（包括粗细、样式等）
- **修改内容**:
  1. **CharacterStyle 类修改**：
     - 默认构造函数使用 `QFont()` 系统默认字体，而不是硬编码 "Times New Roman"
     - 确保默认字号为 12 号
     - clearProperty() 方法中 FontFamily 也改为使用系统默认字体族
  2. **FormatController 类修改**：
     - getCurrentDisplayStyle() 中，当光标在文档开头时，返回 `CharacterStyle()` 默认样式而不是空样式
  3. **RibbonBar 类修改**：
     - updateFromSelection() 中优化字体设置逻辑：
       - 方法1：优先通过字体族名称在下拉框中查找匹配项并设置索引（更可靠）
       - 方法2：如果找不到，再使用 setCurrentFont() 作为备选方案
- **编译状态**：✅ 编译成功
- **影响**：
  - 无选区时，工具栏现在能正确显示光标前一个字符的样式（特别是字体）
  - 字体匹配更可靠，使用系统默认字体避免了硬编码问题
  - 文档开头也能正确显示默认样式

## 修改跨Span选区时工具栏行为：显示最后一个选中字符的样式
- **日期**: 2026-02-19
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **修改前行为**：当选择跨多个 Span（样式不一致）时，工具栏不显示任何样式（混合状态）
- **修改后行为**：无论选择是否跨多个 Span，工具栏始终显示最后一个选中字符的样式
- **修改内容**:
  - 简化 `MainWindow::updateStyleState()` 方法
  - 移除样式一致性检查和混合状态逻辑
  - 始终调用 `m_ribbonBar->updateFromSelection(style, true)` 正常显示样式
  - `getCurrentDisplayStyle()` 本身已经返回：
    - 无选区：光标前一个字符的样式
    - 有选区：选区终点（Focus）前一个字符的样式（即最后一个选中字符的样式）
- **编译状态**：✅ 编译成功
- **影响**：
  - 跨多个 Span 选择时，工具栏现在显示最后一个选中字符的样式
  - 行为更简洁直观，符合用户期望

## 修正选区最后字符位置的计算逻辑
- **日期**: 2026-02-19
- **修改文件**: `src/editcontrol/formatting/FormatController.cpp`
- **问题原因**: 原代码使用 focus 位置（依赖选择方向）来确定最后一个字符，与选区内实际最后一个字符不一致
- **修改内容**:
  - 修改 `getCurrentDisplayStyle()` 方法
  - 有选区时，先获取选区范围并归一化
  - 使用归一化后的 `endBlock` 和 `endOffset` 作为选区结束位置
  - 选区内最后一个字符 = `endOffset - 1`（与选择方向无关）
- **编译状态**：✅ 编译成功
- **影响**：
  - 无论用户从左向右还是从右向左选择，工具栏都显示选区内实际最后一个字符的样式
  - 行为更加一致和可靠

## 恢复选择文字时光标显示
- **日期**: 2026-02-19
- **修改文件**: `src/ui/mainwindow/MainWindow.cpp`
- **修改前行为**：选择文字时，光标会自动隐藏
- **修改后行为**：选择文字时，光标始终保持显示
- **修改内容**:
  - 修改了两个信号连接中的光标可见性控制：
    1. `EditEventHandler::selectionNeedsUpdate` 信号处理
    2. `Selection::selectionChanged` 信号处理
  - 移除了有选区时隐藏光标的逻辑
  - 统一改为始终调用 `m_scene->setCursorVisible(true)` 显示光标
- **编译状态**：✅ 编译成功
- **影响**：
  - 选择文字时，光标现在始终可见
  - 用户可以同时看到选区和光标位置

## 恢复使用 focus 位置确定最后一个字符
- **日期**: 2026-02-19
- **修改文件**: `src/editcontrol/formatting/FormatController.cpp`
- **修改内容**: 改回使用选区的 focus 位置来确定工具栏显示的字符样式，而不是归一化选区的 end 位置
- **修改原因**: 从左向右选和从右向左选时，用户希望工具栏显示不同的字符样式（依赖于选择方向）
- **编译状态**：✅ 编译成功
- **影响**：
  - 从左向右选择：工具栏显示选区右侧（focus 位置前）的字符样式
  - 从右向左选择：工具栏显示选区左侧（focus 位置前）的字符样式
  - 行为与选择方向一致，符合用户期望

## 根据选区方向确定工具栏显示的字符
- **日期**: 2026-02-19
- **修改文件**: `src/editcontrol/formatting/FormatController.cpp`
- **修改内容**: 
  - 判断选区方向：通过比较 anchor 和 focus 的位置
  - 从左向右选择（anchor < focus）：取 focus-1 位置的字符
  - 从右向左选择（anchor > focus）：取 focus 位置的字符
- **修改原因**: 用户要求从右向左选择时，工具栏显示选区左侧（focus 位置后）的字符样式
- **编译状态**：✅ 编译成功
- **影响**：
  - 从左向右选择：工具栏显示选区右侧最后一个字符的样式
  - 从右向左选择：工具栏显示选区左侧第一个字符的样式

## 修改加粗/斜体/下划线按钮逻辑：根据当前样式进行切换
- **日期**: 2026-02-19
- **修改文件**: 
  - `src/editcontrol/formatting/FormatController.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **修改前行为**: 点击按钮后直接设置为按钮当前状态（true/false），不根据选区内当前样式进行切换
- **修改后行为**: 
  - 点击按钮后根据选区内最后一个字符的当前样式进行切换
  - 有选区时：切换选区内字符的样式
  - 无选区时：切换新输入字符的样式
- **修改内容**:
  1. FormatController：
     - 修改 `setBold()`、`setItalic()`、`setUnderline()` 方法
     - 忽略传入的参数，获取当前显示样式，取反后再应用
  2. MainWindow：
     - 修改 RibbonBar 的信号连接
     - 同样根据当前显示样式进行切换
- **编译状态**：✅ 编译成功
- **影响**：
  - 选中文字后点击加粗，文字会加粗
  - 再次点击加粗，加粗效果会取消
  - 斜体和下划线按钮同样支持切换功能

## 彻底修复加粗/斜体/下划线按钮切换功能（使用 triggered 信号）
- **日期**: 2026-02-19
- **修改文件**: 
  - `include/ui/ribbon/RibbonBar.h`
  - `src/ui/ribbon/RibbonBar.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题根源**: 使用 `toggled` 信号时，按钮状态变化和逻辑切换会造成循环和冲突
- **解决方案**:
  1. 在 RibbonBar 中添加新的无参数信号：`boldTriggered`、`italicTriggered`、`underlineTriggered`
  2. 将按钮连接改为使用 `triggered` 信号，而不是 `toggled` 信号
  3. 在 MainWindow 中连接新的信号，进行样式切换
  4. RibbonBar 中的 `updateFromSelection` 方法已使用 QSignalBlocker，避免更新按钮状态时触发信号
- **编译状态**：✅ 编译成功
- **影响**：
  - 选中文字后点击加粗，文字会加粗
  - 再次点击加粗，加粗效果会取消
  - 斜体和下划线按钮同样支持切换功能
  - 按钮状态与实际样式同步

## 修复加粗/斜体/下划线按钮切换功能
- **日期**: 2026-02-19
- **修改文件**: 
  - `src/editcontrol/formatting/FormatController.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: FormatController 的方法忽略了传入的参数，导致无法正确应用样式
- **解决方案**:
  1. 恢复 FormatController 的原始方法实现，使用传入的参数
  2. 在 MainWindow 中，根据当前显示样式计算出新的状态，再传递给 FormatController
  3. RibbonBar 中已使用 QSignalBlocker 阻止更新按钮状态时触发信号
- **编译状态**：✅ 编译成功
- **影响**：
  - 选中文字后点击加粗，文字会加粗
  - 再次点击加粗，加粗效果会取消
  - 斜体和下划线按钮同样支持切换功能

## 彻底修复加粗/斜体/下划线按钮切换功能（使用 triggered 信号）
- **日期**: 2026-02-19
- **修改文件**: 
  - `include/ui/ribbon/RibbonBar.h`
  - `src/ui/ribbon/RibbonBar.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题根源**: 使用 `toggled` 信号时，按钮状态变化和逻辑切换会造成循环和冲突
- **解决方案**:
  1. 在 RibbonBar 中添加新的无参数信号：`boldTriggered`、`italicTriggered`、`underlineTriggered`
  2. 将按钮连接改为使用 `triggered` 信号，而不是 `toggled` 信号
  3. 在 MainWindow 中连接新的信号，进行样式切换
  4. RibbonBar 中的 `updateFromSelection` 方法已使用 QSignalBlocker，避免更新按钮状态时触发信号
- **编译状态**：✅ 编译成功
- **影响**：
  - 选中文字后点击加粗，文字会加粗
  - 再次点击加粗，加粗效果会取消
  - 斜体和下划线按钮同样支持切换功能
  - 按钮状态与实际样式同步

## 修复从段首开始选择后加粗导致整段都加粗的问题（真正修复）
- **日期**: 2026-02-19 14:40:00
- **修改文件**: 
  - `src/core/document/ParagraphBlock.cpp`
  - `src/editcontrol/handlers/EditEventHandler.cpp`
  - `src/graphics/items/TextBlockItem.cpp`
- **真正的问题根源**: 
  - 在同一个 span 内处理样式时，删除原始 span 之前没有显式保存原始样式的副本
  - 由于某种原因（可能涉及隐式共享或样式合并操作的副作用），原始 span 的样式在处理过程中被污染，导致 after 部分的 span 也被错误地应用了新样式
- **解决方案**:
  1. **同一个 span 内处理修复**：
     - 在删除原始 span 之前，显式保存 `originalStyle = span.style()` 副本
     - 使用 `originalStyle` 创建 before 和 after 部分的 span，而不是直接使用 `span.style()`
     - 添加详细调试输出，跟踪原始样式和合并后样式的值
  2. **跨 span 处理保持一致性**：
     - 将原来的注释从"保存原始样式引用"更新为"保存原始样式的副本！防止隐式共享问题！"
     - 确保两种处理路径（同一个 span 和跨 span）的代码风格一致
  3. **添加更多调试输出**：
     - 在 TextBlockItem::applyRichTextFromBlock 中添加调试，显示每个 span 的加粗状态
     - 在 ParagraphBlock::setStyle 中添加 mergeAdjacentSpans 前后的 spans 状态
     - 在同一个 span 处理中添加原始样式和合并后样式的调试
- **编译状态**：✅ 编译成功
- **验证结果**：
  - `mergeAdjacentSpans 之前的 spans:`
    - `span 0: text=["这是第一段"], 加粗: true`
    - `span 1: text=["测试文字。欢迎使用 QtWordEditor 文字编辑器！"], 加粗: false`
  - `mergeAdjacentSpans 之后的 spans:`
    - `span 0: text=["这是第一段"], 加粗: true`
    - `span 1: text=["测试文字。欢迎使用 QtWordEditor 文字编辑器！"], 加粗: false`
  - ✅ 只有选中范围被加粗，未选中范围保持原样
- **影响**：
  - 从段首开始选择文本后，点击加粗按钮，只会加粗选中的文本，而不会整段都加粗
  - 同一段内的部分选择现在可以正确处理
  - 跨 span 的样式应用也保持正确
  - 添加了完整的调试输出，便于未来问题排查

## 修复单个Span内选择时工具栏样式显示问题，以及跨Span选择显示混合状态
- **日期**: 2026-02-19 15:00:00
- **修改文件**: 
  - `src/editcontrol/formatting/FormatController.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
  - `src/graphics/items/TextBlockItem.cpp`
- **问题原因**: 
  1. **单个Span内选择时工具栏样式显示错误**：当反向选择且选区完全在单个Span内时，代码错误地获取到前一个Span的样式
  2. **缺少样式一致性检查方法**：FormatController的isSelectionStyleConsistent()方法没有实现
  3. **Span边界不清晰**：用户无法直观看到Span的边界和样式
- **解决方案**:
  1. **单个Span内选择修复**：
     - 修改 `getCurrentDisplayStyle()` 方法，优先检查选区是否完全在单个Span内
     - 如果是，直接使用该Span的样式，避免计算位置错误
  2. **实现isSelectionStyleConsistent()**：
     - 检查选区是否跨多个块或多个Span
     - 单个Span内返回true（样式一致），跨多个Span返回false（样式不一致）
  3. **添加Span视觉调试**：
     - 给每个Span添加3种交替颜色的边框和背景
     - 使用HTML格式渲染，确保边框可见
     - 添加调试输出显示选中的Span数量和详情
  4. **MainWindow修改**：
     - 使用isSelectionStyleConsistent()判断样式是否一致
     - 一致时显示样式，不一致时显示混合状态
- **最终行为**:
  | 场景 | 说明 | 工具栏行为 |
  |------|------|-----------|
  | 场景1：无选区 | 只有光标 | 显示光标前一个字符的样式 |
  | 场景2：单个Span内选择 | 选区内所有字符样式相同 | 显示该Span的样式 |
  | 场景3：跨多个Span选择 | 选区内有多种不同样式 | **显示混合状态（空状态） |
- **编译状态**：✅ 编译成功
- **验证结果**:
  - 单个Span内选择，无论选择方向如何，都正确显示该Span样式
  - 跨多个Span选择时，工具栏显示混合状态
  - Span边界通过彩色边框清晰可见
  - 调试输出显示选中的Span数量和详情
- **影响**：
  - 工具栏现在能正确显示单个Span内选择的样式
  - 跨多个Span选择时显示混合状态，符合用户期望
  - 通过彩色边框可以直观调试Span边界

## 分别检查每个样式属性的一致性，而不是整体显示空状态
- **日期**: 2026-02-19 15:15:00
- **修改文件**: 
  - `include/editcontrol/formatting/FormatController.h`
  - `src/editcontrol/formatting/FormatController.cpp`
  - `include/ui/ribbon/RibbonBar.h`
  - `src/ui/ribbon/RibbonBar.cpp`
  - `src/ui/mainwindow/MainWindow.cpp`
- **问题原因**: 
  - 原来的实现是整体判断选区样式是否一致，如果不一致就整体显示空状态
  - 这样不够精细，应该分别检查每个属性（粗体、斜体、下划线、字体、字号）
  - 如果某个属性在所有选中的Span中都一致，就应该显示该属性；如果不一致，就显示混合状态
- **解决方案**:
  1. **FormatController 修改**：
     - 添加 `StyleConsistency` 结构体，分别保存每个属性的一致性状态
     - 实现 `getSelectionStyleConsistency()` 方法，收集所有与选区重叠的Span，逐个比较每个属性
     - 保持 `isSelectionStyleConsistent()` 方法用于向后兼容
  2. **RibbonBar 修改**：
     - 添加同样的 `StyleConsistency` 结构体
     - 实现新的 `updateFromSelection(const CharacterStyle &style, const StyleConsistency &consistency)` 方法
     - 该方法根据每个属性的一致性状态单独处理：
       - 如果一致，显示该属性
       - 如果不一致，显示混合状态（清空/取消选中）
  3. **MainWindow 修改**：
     - 有选区时，先检查是否完全在单个Span内
     - 如果是，直接显示一致样式
     - 如果不是，获取每个属性的一致性状态，然后传递给RibbonBar
- **最终行为**:
  | 场景 | 说明 | 工具栏行为 |
  |------|------|-----------|
  | 无选区 | 只有光标 | 显示光标前一个字符的所有样式 |
  | 单个Span内选择 | 选区内所有字符样式相同 | 显示该Span的所有样式 |
  | 跨多个Span选择，只有粗体不一致 | 选区内粗体有不同，其他都相同 | 粗体显示混合状态，其他都正常显示 |
  | 跨多个Span选择，多个属性不一致 | 多个属性有不同 | 只有不一致的属性显示混合状态 |
- **编译状态**：✅ 代码已修改完成，等待编译测试
- **影响**：
  - 工具栏现在能分别处理每个属性的一致性
  - 只有不一致的属性才会显示混合状态，一致的属性仍然正常显示
  - 行为更加精细和合理
