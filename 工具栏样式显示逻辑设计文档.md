# 工具栏样式显示逻辑详细设计文档

## 目录
1. [需求概述](#1-需求概述)
2. [核心概念澄清](#2-核心概念澄清)
3. [详细设计方案](#3-详细设计方案)
4. [更新计划](#4-更新计划)
5. [交互流程图](#5-交互流程图)
6. [测试用例](#6-测试用例)

---

## 1. 需求概述

### 1.1 问题背景
在文字处理器中，当用户选中文本时，工具栏应该显示什么样的样式状态，这是一个关键的用户体验问题。

### 1.2 具体需求
- **无选区时**：显示光标前一个字符的样式
- **有选区时**：显示**最后一个选中字符**的样式（不是选区的第一个字符，也不是文档的最后一个字符）

### 1.3 关键区别
| 术语 | 说明 |
|------|------|
| **最后一个选中字符** | 选区的终点位置的字符（取决于选择方向） |
| **选区的最后一个字符** | 选区在文档中的物理最后位置的字符 |
| **文档的最后一个字符** | 整个文档的结尾字符 |

---

## 2. 核心概念澄清

### 2.1 选区的两个关键位置

在文本选择系统中，选区有两个重要的位置：

```
┌─────────────────────────────────────────────────────────┐
│  H e l l o   W o r l d                                 │
│  ↑         ↑                                           │
│  Anchor   Focus                                        │
│  (起点)   (终点)                                       │
└─────────────────────────────────────────────────────────┘
```

- **Anchor（锚点）**：选择开始时的位置，固定不变
- **Focus（焦点）**：选择结束时的位置，随鼠标/键盘移动

### 2.2 选择方向与最后一个选中字符

**场景 A：从左向右选择**
```
文本:    H e l l o   W o r l d
选择:    [ A n c h o r → F o c u s ]
         ↑                   ↑
       起点                 终点
                           ↑
                    最后一个选中字符 = 'd'
```

**场景 B：从右向左选择**
```
文本:    H e l l o   W o r l d
选择:    [ F o c u s ← A n c h o r ]
         ↑                   ↑
       终点                 起点
         ↑
    最后一个选中字符 = 'H'
```

### 2.3 关键结论
✅ **最后一个选中字符 = Focus 位置的前一个字符**

---

## 3. 详细设计方案

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        MainWindow                                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  1. 监听光标/选区变化                                     │  │
│  │  2. 调用 FormatController 获取样式信息                   │  │
│  │  3. 更新 RibbonBar 显示                                  │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                    FormatController (新增)                       │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  - getStyleAtCursor(): 获取光标处样式                     │  │
│  │  - getStyleAtSelectionEnd(): 获取选区终点样式              │  │
│  │  - getCurrentDisplayStyle(): 获取当前应显示的样式         │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                       RibbonBar                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  - updateFromSelection(style): 更新工具栏显示              │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 FormatController 新增方法

#### 3.2.1 方法 1：获取当前应该显示的样式
```cpp
/**
 * @brief 获取当前应该在工具栏显示的样式
 * 
 * 逻辑：
 * - 有选区：返回选区终点（Focus）的前一个字符的样式
 * - 无选区：返回光标前一个字符的样式
 * 
 * @return 应该显示的字符样式
 */
CharacterStyle getCurrentDisplayStyle() const;
```

#### 3.2.2 方法 2：获取选区终点的位置
```cpp
/**
 * @brief 获取选区的终点位置（Focus）
 * 
 * @return 选区终点的位置 {blockIndex, offset}
 */
CursorPosition getSelectionEndPosition() const;
```

#### 3.2.3 方法 3：获取指定位置的样式
```cpp
/**
 * @brief 获取指定位置的字符样式
 * 
 * @param blockIndex 块索引
 * @param offset 块内偏移量
 * @return 该位置的字符样式
 */
CharacterStyle getStyleAtPosition(int blockIndex, int offset) const;
```

### 3.3 具体实现逻辑

#### 3.3.1 getCurrentDisplayStyle() 实现逻辑

```
函数开始
    ↓
┌─────────────────────────────┐
│  是否有选区？               │
└─────────────┬───────────────┘
              │
       ┌──────┴───────┐
       │              │
      有            无
       │              │
       ↓              ↓
┌─────────────┐  ┌─────────────┐
│ 获取选区终点 │  │ 获取光标位置 │
│ (Focus)     │  │             │
└──────┬──────┘  └──────┬──────┘
       │                 │
       ↓                 ↓
┌─────────────────────────────┐
│ 计算目标位置 = 终点 - 1    │
└──────────────┬──────────────┘
               │
               ↓
┌─────────────────────────────┐
│ 获取目标位置的样式          │
└──────────────┬──────────────┘
               │
               ↓
        返回该样式
```

#### 3.3.2 选区终点判断逻辑

我们需要从 Selection 类中获取选区的两个端点，然后判断哪个是终点（Focus）。

```cpp
CursorPosition FormatController::getSelectionEndPosition() const
{
    if (!m_selection)
        return {-1, 0};
    
    SelectionRange range = m_selection->range();
    
    // 注意：这里假设 SelectionRange 存储的是 {start, end}，
    // 但实际上我们需要知道哪个是 anchor，哪个是 focus！
    
    // TODO: 需要扩展 Selection 类来追踪 anchor 和 focus
    
    // 临时方案：暂时返回 range.end（假设选区是从左到右）
    return {range.endBlock, range.endOffset};
}
```

### 3.4 需要扩展的类

#### 3.4.1 Selection 类扩展

当前 Selection 类可能只存储了归一化的范围，我们需要扩展它来追踪选择方向：

```cpp
struct SelectionRange
{
    int anchorBlock = -1;      // 锚点块索引
    int anchorOffset = 0;       // 锚点偏移
    int focusBlock = -1;       // 焦点块索引
    int focusOffset = 0;        // 焦点偏移
    
    // ... 现有方法 ...
    
    /**
     * @brief 获取焦点位置（最后一个选中字符的位置）
     */
    CursorPosition focusPosition() const {
        return {focusBlock, focusOffset};
    }
};
```

---

## 3.5 当前输入样式机制设计

### 3.5.1 问题背景

在文字编辑器中，存在两种典型的输入场景：

**场景 1：直接打字（继承前一个字符样式）**
```
文本:    [普通][粗体][普通]
          ↑
         光标位置

操作:    直接输入 "x"

结果:    "x" 继承光标前字符的样式（粗体）
```

**场景 2：先设置样式再打字（使用用户设置的样式）**
```
文本:    [普通][粗体][普通]
          ↑
         光标位置

操作:    点击工具栏"斜体"按钮 → 输入 "x"

结果:    "x" 使用用户设置的样式（斜体），而不是继承粗体
```

### 3.5.2 核心概念

引入一个关键变量：**`m_currentInputStyle`**

| 概念 | 说明 |
|------|------|
| **当前输入样式** | 用户接下来打字时应该使用的字符样式 |
| **显示样式** | 工具栏当前显示的样式（用于UI反馈） |
| **继承模式** | `m_currentInputStyle` 跟随光标移动而变化，继承前一个字符样式 |
| **覆盖模式** | 用户显式设置工具栏样式后，`m_currentInputStyle` 被固定，直到光标移动 |

### 3.5.3 状态机设计

```
┌─────────────────────────────────────────────────────────────────┐
│                        状态转换图                                  │
└─────────────────────────────────────────────────────────────────┘

初始状态：继承模式
    ↓
┌─────────────────────────────────────────────────────────────────┐
│  [继承模式]                                                       │
│  - 光标移动时：m_currentInputStyle = 前一个字符样式              │
│  - 打字时：使用 m_currentInputStyle                              │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 用户点击工具栏样式按钮
    ↓
┌─────────────────────────────────────────────────────────────────┐
│  [覆盖模式]                                                       │
│  - m_currentInputStyle = 用户设置的样式                          │
│  - 打字时：使用 m_currentInputStyle                              │
└─────────────────────────────────────────────────────────────────┘
    │
    │ 用户移动光标
    ↓
回到 [继承模式]
```

### 3.5.4 FormatController 扩展

#### 3.5.4.1 新增成员变量

```cpp
private:
    CharacterStyle m_currentInputStyle;  ///< 当前输入样式
    bool m_isInputStyleOverridden;       ///< 是否处于覆盖模式（用户手动设置过样式）
```

#### 3.5.4.2 新增方法

```cpp
public:
    /**
     * @brief 获取当前输入样式（用于打字时使用）
     * @return 当前应该使用的输入样式
     */
    CharacterStyle getCurrentInputStyle() const;

    /**
     * @brief 设置当前输入样式（用户通过工具栏手动设置样式时调用）
     * @param style 用户设置的样式
     */
    void setCurrentInputStyle(const CharacterStyle &style);

    /**
     * @brief 光标移动时调用，更新当前输入样式（继承模式）
     */
    void onCursorMoved();
```

### 3.5.5 详细实现逻辑

#### 3.5.5.1 FormatController 初始化

```cpp
FormatController::FormatController(...)
    : ...
    , m_isInputStyleOverridden(false)
{
    // 初始时，当前输入样式为空（使用默认样式）
}
```

#### 3.5.5.2 onCursorMoved() - 光标移动时

```cpp
void FormatController::onCursorMoved()
{
    // 光标移动时，退出覆盖模式，回到继承模式
    m_isInputStyleOverridden = false;
    
    // 更新当前输入样式为光标前一个字符的样式
    m_currentInputStyle = getCurrentDisplayStyle();
}
```

#### 3.5.5.3 setCurrentInputStyle() - 用户手动设置样式时

```cpp
void FormatController::setCurrentInputStyle(const CharacterStyle &style)
{
    // 用户通过工具栏设置样式，进入覆盖模式
    m_isInputStyleOverridden = true;
    
    // 合并样式：如果用户只设置了部分属性（如只设置粗体），
    // 则保留其他属性的当前值
    if (m_isInputStyleOverridden) {
        m_currentInputStyle = m_currentInputStyle.mergeWith(style);
    } else {
        m_currentInputStyle = getCurrentDisplayStyle().mergeWith(style);
    }
}
```

#### 3.5.5.4 getCurrentInputStyle() - 获取输入样式

```cpp
CharacterStyle FormatController::getCurrentInputStyle() const
{
    if (m_isInputStyleOverridden) {
        // 覆盖模式：返回用户设置的样式
        return m_currentInputStyle;
    } else {
        // 继承模式：返回光标前一个字符的样式
        return getCurrentDisplayStyle();
    }
}
```

### 3.5.6 集成到文本输入流程

#### 3.5.6.1 EditEventHandler 修改

在 `EditEventHandler::handleKeyPress()` 和 `handleInputMethod()` 中：

```cpp
// 原来的代码
CharacterStyle style; // 默认样式
m_cursor->insertText(event->text(), style);

// 修改后
CharacterStyle style = m_formatController->getCurrentInputStyle();
m_cursor->insertText(event->text(), style);
```

#### 3.5.6.2 MainWindow 修改

在工具栏按钮点击事件中（如粗体按钮）：

```cpp
void MainWindow::onBoldButtonClicked(bool checked)
{
    CharacterStyle style;
    style.setBold(checked);
    
    if (m_selection->isEmpty()) {
        // 无选区：设置当前输入样式
        m_formatController->setCurrentInputStyle(style);
    } else {
        // 有选区：应用到选中文本
        m_formatController->applyCharacterStyle(style);
    }
    
    // 更新工具栏显示
    updateStyleState();
}
```

#### 3.5.6.3 光标移动信号连接

```cpp
// 在 MainWindow 初始化时
connect(m_cursor, &Cursor::positionChanged,
        m_formatController, &FormatController::onCursorMoved);
connect(m_cursor, &Cursor::positionChanged,
        this, &MainWindow::updateStyleState);
```

### 3.5.7 完整交互示例

**示例 1：直接打字（继承模式）**
```
1. 输入 "Hello"（普通样式）
2. 光标在 "o" 后面
3. 直接输入 " World"
   → " World" 继承 "o" 的普通样式
```

**示例 2：先设置样式再打字（覆盖模式）**
```
1. 输入 "Hello"（普通样式）
2. 光标在 "o" 后面
3. 点击工具栏"粗体"按钮
   → m_isInputStyleOverridden = true
   → m_currentInputStyle = 粗体
4. 输入 " World"
   → " World" 使用粗体样式
5. 移动光标到其他位置
   → m_isInputStyleOverridden = false（回到继承模式）
```

**示例 3：连续设置多个样式**
```
1. 光标在某个位置
2. 点击"粗体" → m_currentInputStyle = {bold: true}
3. 点击"斜体" → m_currentInputStyle = {bold: true, italic: true}
4. 输入文字 → 粗斜体
```

---

## 4. 更新计划

### 4.1 阶段 1：扩展 Selection 类
**目标**：让 Selection 类能够追踪锚点和焦点

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 1.1 修改 SelectionRange 结构体 | 添加 anchorBlock/Offset 和 focusBlock/Offset | 30 分钟 |
| 1.2 修改 Selection::setRange() | 保存选择时的起点和终点 | 30 分钟 |
| 1.3 修改 Selection::extend() | 更新焦点位置 | 30 分钟 |
| 1.4 添加 Selection::focusPosition() | 获取焦点位置的方法 | 15 分钟 |
| **小计** | | **2 小时** |

### 4.2 阶段 2：完善 FormatController 类
**目标**：添加获取显示样式的方法

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 2.1 添加 getStyleAtPosition() | 获取指定位置的样式 | 30 分钟 |
| 2.2 添加 getSelectionEndPosition() | 获取选区终点位置 | 15 分钟 |
| 2.3 添加 getCurrentDisplayStyle() | 主方法，判断显示逻辑 | 45 分钟 |
| 2.4 单元测试 | 测试各种边界情况 | 1 小时 |
| **小计** | | **2.5 小时** |

### 4.3 阶段 3：修改 MainWindow 类
**目标**：更新样式状态更新流程

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 3.1 修改 updateStyleState() | 调用新的 getCurrentDisplayStyle() | 30 分钟 |
| 3.2 连接 Selection::selectionChanged 信号 | 选区变化时更新显示 | 15 分钟 |
| **小计** | | **45 分钟** |

### 4.4 阶段 4：完善 RibbonBar 类
**目标**：更新显示逻辑

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 4.1 修改 updateFromSelection() | 接受完整的 CharacterStyle 参数 | 30 分钟 |
| 4.2 更新所有样式控件显示 | 字体、字号、粗体、斜体等 | 1 小时 |
| **小计** | | **1.5 小时** |

### 4.5 阶段 5：实现当前输入样式机制
**目标**：添加当前输入样式变量和相关逻辑

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 5.1 FormatController 添加成员变量 | m_currentInputStyle 和 m_isInputStyleOverridden | 15 分钟 |
| 5.2 实现 onCursorMoved() 方法 | 光标移动时更新输入样式 | 30 分钟 |
| 5.3 实现 setCurrentInputStyle() 方法 | 用户设置样式时的处理逻辑 | 30 分钟 |
| 5.4 实现 getCurrentInputStyle() 方法 | 获取当前输入样式 | 15 分钟 |
| 5.5 修改 EditEventHandler | 打字时使用当前输入样式 | 30 分钟 |
| 5.6 修改 MainWindow 工具栏按钮 | 无选区时设置输入样式 | 45 分钟 |
| 5.7 连接光标移动信号 | 连接 Cursor::positionChanged | 15 分钟 |
| **小计** | | **2.5 小时** |

### 4.6 阶段 6：集成测试
**目标**：完整测试所有场景

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 6.1 无选区场景测试 | 光标移动、直接打字 | 30 分钟 |
| 6.2 有选区场景测试 | 从左到右、从右到左选择 | 45 分钟 |
| 6.3 当前输入样式测试 | 继承模式、覆盖模式 | 1 小时 |
| 6.4 边界情况测试 | 选区在文档开头/结尾 | 30 分钟 |
| **小计** | | **2.5 小时** |

### 总体时间估算

| 阶段 | 时间 |
|------|------|
| 阶段 1：扩展 Selection | 2 小时 |
| 阶段 2：完善 FormatController | 2.5 小时 |
| 阶段 3：修改 MainWindow | 45 分钟 |
| 阶段 4：完善 RibbonBar | 1.5 小时 |
| 阶段 5：实现当前输入样式机制 | 2.5 小时 |
| 阶段 6：集成测试 | 2.5 小时 |
| **总计** | **12 小时（约 1.5 个工作日）** |

---

## 5. 交互流程图

### 5.1 完整的显示更新流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    触发事件（光标移动/选区变化）                │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  MainWindow::updateStyleState()                                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 1. 调用 FormatController::getCurrentDisplayStyle()      │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  FormatController::getCurrentDisplayStyle()                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 2. 检查是否有选区                                        │  │
│  │    ├─ 有选区：→ 获取焦点位置（Focus）                   │  │
│  │    │         → 目标位置 = 焦点位置 - 1                 │  │
│  │    │         → 获取该位置的样式                          │  │
│  │    │                                                      │  │
│  │    └─ 无选区：→ 获取光标位置                            │  │
│  │              → 目标位置 = 光标位置 - 1                 │  │
│  │              → 获取该位置的样式                          │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  FormatController::getStyleAtPosition()                        │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 3. 验证位置有效性                                        │  │
│  │ 4. 找到对应的 ParagraphBlock                            │  │
│  │ 5. 调用 ParagraphBlock::styleAt()                       │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  返回 CharacterStyle 给 MainWindow                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  MainWindow 调用 RibbonBar::updateFromSelection(style)       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  RibbonBar::updateFromSelection()                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 6. 使用 QSignalBlocker 防止信号循环                      │  │
│  │ 7. 更新字体下拉框                                        │  │
│  │ 8. 更新字号下拉框                                        │  │
│  │ 9. 更新粗体按钮状态                                      │  │
│  │ 10. 更新斜体按钮状态                                     │  │
│  │ 11. 更新下划线按钮状态                                   │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    ✅ 工具栏显示更新完成！                        │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 测试用例

### 6.1 测试场景 1：无选区，光标在中间

**测试步骤：**
1. 打开文档，输入 "Hello World"
2. 移动光标到 "Hello" 和 "World" 之间（即空格后）
3. 设置 "Hello" 为粗体，"World" 为普通样式
4. 将光标放在空格后（"World" 前）

**预期结果：**
- 工具栏显示：光标前字符（空格）的样式
- 如果空格是普通样式，则工具栏显示普通样式

---

### 6.2 测试场景 2：有选区，从左到右选择

**测试步骤：**
1. 输入 "ABCDE"
2. 设置 "A" 为普通，"B" 为粗体，"C" 为斜体，"D" 为粗斜体，"E" 为普通
3. 从左到右选择 "BCD"（从 B 开始，到 E 之前结束）

**选区图示：**
```
A [ B C D ] E
  ↑       ↑
Anchor  Focus
         ↑
      最后一个选中字符是 D
```

**预期结果：**
- 工具栏显示：D 的样式（粗斜体）

---

### 6.3 测试场景 3：有选区，从右到左选择

**测试步骤：**
1. 输入 "ABCDE"
2. 设置样式同上
3. 从右到左选择 "BCD"（从 D 开始，到 A 之后结束）

**选区图示：**
```
A [ B C D ] E
    ↑       ↑
  Focus   Anchor
    ↑
最后一个选中字符是 B
```

**预期结果：**
- 工具栏显示：B 的样式（粗体）

---

### 6.4 测试场景 4：选区在文档开头

**测试步骤：**
1. 输入 "Hello"
2. 从左到右选择 "He"
3. 或者从右到左选择 "He"

**预期结果：**
- 从左到右选择：显示第二个字符 'e' 的样式
- 从右到左选择：显示第一个字符 'H' 的样式

---

### 6.5 测试场景 5：选区在文档结尾

**测试步骤：**
1. 输入 "Hello"
2. 选择整个单词 "Hello"

**预期结果：**
- 从左到右选择：显示最后一个字符 'o' 的样式
- 从右到左选择：显示第一个字符 'H' 的样式

---

### 6.6 测试场景 6：当前输入样式 - 继承模式（直接打字）

**测试步骤：**
1. 输入 "Hello World"，其中 "Hello" 为粗体，"World" 为普通
2. 将光标放在 "World" 的开头（空格后）
3. 直接输入 "x"

**预期结果：**
- "x" 继承光标前字符（空格）的样式（普通样式）

---

### 6.7 测试场景 7：当前输入样式 - 覆盖模式（先设置样式再打字）

**测试步骤：**
1. 输入 "Hello World"，其中 "Hello" 为粗体，"World" 为普通
2. 将光标放在 "World" 的开头（空格后）
3. 点击工具栏"粗体"按钮
4. 输入 "x"

**预期结果：**
- "x" 使用用户设置的样式（粗体），而不是继承空格的普通样式

---

### 6.8 测试场景 8：当前输入样式 - 光标移动回到继承模式

**测试步骤：**
1. 输入 "Hello World"
2. 点击工具栏"粗体"按钮（进入覆盖模式）
3. 移动光标到其他位置
4. 输入 "x"

**预期结果：**
- 光标移动后，自动回到继承模式
- "x" 继承光标前字符的样式

---

### 6.9 测试场景 9：当前输入样式 - 连续设置多个样式

**测试步骤：**
1. 光标在某个位置
2. 点击"粗体"按钮
3. 点击"斜体"按钮
4. 输入 "x"

**预期结果：**
- "x" 同时具有粗体和斜体样式

---

### 6.10 测试场景 10：有选区时应用样式 vs 无选区时设置输入样式

**测试步骤 A（有选区）：**
1. 输入 "Hello"
2. 选中 "ell"
3. 点击"粗体"按钮

**预期结果 A：**
- 选中文本 "ell" 变为粗体

**测试步骤 B（无选区）：**
1. 输入 "Hello"
2. 不选中文本，点击"粗体"按钮
3. 输入 " World"

**预期结果 B：**
- " World" 使用粗体样式（设置了输入样式）

---

## 文档信息

- **创建日期**：2026-02-18
- **版本**：v2.0
- **作者**：QtWordEditor 开发团队
- **状态**：待评审
- **更新记录**：
  - v1.0 (2026-02-18): 初始版本，工具栏显示逻辑
  - v2.0 (2026-02-18): 添加当前输入样式机制设计
