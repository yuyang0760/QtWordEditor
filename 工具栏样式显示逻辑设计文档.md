# 工具栏样式显示逻辑详细设计文档

## 目录
1. [需求概述](#1-需求概述)
2. [核心概念澄清](#2-核心概念澄清)
3. [详细设计方案](#3-详细设计方案)
4. [更新计划](#4-更新计划)
5. [交互流程图](#5-交互流程图)
6. [测试用例](#6-测试用例)

---

## 1. 需求概述

### 1.1 问题背景
在文字处理器中，当用户选中文本时，工具栏应该显示什么样的样式状态，这是一个关键的用户体验问题。

### 1.2 具体需求
- **无选区时**：显示光标前一个字符的样式
- **有选区时**：显示**最后一个选中字符**的样式（不是选区的第一个字符，也不是文档的最后一个字符）

### 1.3 关键区别
| 术语 | 说明 |
|------|------|
| **最后一个选中字符** | 选区的终点位置的字符（取决于选择方向） |
| **选区的最后一个字符** | 选区在文档中的物理最后位置的字符 |
| **文档的最后一个字符** | 整个文档的结尾字符 |

---

## 2. 核心概念澄清

### 2.1 选区的两个关键位置

在文本选择系统中，选区有两个重要的位置：

```
┌─────────────────────────────────────────────────────────┐
│  H e l l o   W o r l d                                 │
│  ↑         ↑                                           │
│  Anchor   Focus                                        │
│  (起点)   (终点)                                       │
└─────────────────────────────────────────────────────────┘
```

- **Anchor（锚点）**：选择开始时的位置，固定不变
- **Focus（焦点）**：选择结束时的位置，随鼠标/键盘移动

### 2.2 选择方向与最后一个选中字符

**场景 A：从左向右选择**
```
文本:    H e l l o   W o r l d
选择:    [ A n c h o r → F o c u s ]
         ↑                   ↑
       起点                 终点
                           ↑
                    最后一个选中字符 = 'd'
```

**场景 B：从右向左选择**
```
文本:    H e l l o   W o r l d
选择:    [ F o c u s ← A n c h o r ]
         ↑                   ↑
       终点                 起点
         ↑
    最后一个选中字符 = 'H'
```

### 2.3 关键结论
✅ **最后一个选中字符 = Focus 位置的前一个字符**

---

## 3. 详细设计方案

### 3.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        MainWindow                                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  1. 监听光标/选区变化                                     │  │
│  │  2. 调用 FormatController 获取样式信息                   │  │
│  │  3. 更新 RibbonBar 显示                                  │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                    FormatController (新增)                       │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  - getStyleAtCursor(): 获取光标处样式                     │  │
│  │  - getStyleAtSelectionEnd(): 获取选区终点样式              │  │
│  │  - getCurrentDisplayStyle(): 获取当前应显示的样式         │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────────┐
│                       RibbonBar                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │  - updateFromSelection(style): 更新工具栏显示              │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 FormatController 新增方法

#### 3.2.1 方法 1：获取当前应该显示的样式
```cpp
/**
 * @brief 获取当前应该在工具栏显示的样式
 * 
 * 逻辑：
 * - 有选区：返回选区终点（Focus）的前一个字符的样式
 * - 无选区：返回光标前一个字符的样式
 * 
 * @return 应该显示的字符样式
 */
CharacterStyle getCurrentDisplayStyle() const;
```

#### 3.2.2 方法 2：获取选区终点的位置
```cpp
/**
 * @brief 获取选区的终点位置（Focus）
 * 
 * @return 选区终点的位置 {blockIndex, offset}
 */
CursorPosition getSelectionEndPosition() const;
```

#### 3.2.3 方法 3：获取指定位置的样式
```cpp
/**
 * @brief 获取指定位置的字符样式
 * 
 * @param blockIndex 块索引
 * @param offset 块内偏移量
 * @return 该位置的字符样式
 */
CharacterStyle getStyleAtPosition(int blockIndex, int offset) const;
```

### 3.3 具体实现逻辑

#### 3.3.1 getCurrentDisplayStyle() 实现逻辑

```
函数开始
    ↓
┌─────────────────────────────┐
│  是否有选区？               │
└─────────────┬───────────────┘
              │
       ┌──────┴───────┐
       │              │
      有            无
       │              │
       ↓              ↓
┌─────────────┐  ┌─────────────┐
│ 获取选区终点 │  │ 获取光标位置 │
│ (Focus)     │  │             │
└──────┬──────┘  └──────┬──────┘
       │                 │
       ↓                 ↓
┌─────────────────────────────┐
│ 计算目标位置 = 终点 - 1    │
└──────────────┬──────────────┘
               │
               ↓
┌─────────────────────────────┐
│ 获取目标位置的样式          │
└──────────────┬──────────────┘
               │
               ↓
        返回该样式
```

#### 3.3.2 选区终点判断逻辑

我们需要从 Selection 类中获取选区的两个端点，然后判断哪个是终点（Focus）。

```cpp
CursorPosition FormatController::getSelectionEndPosition() const
{
    if (!m_selection)
        return {-1, 0};
    
    SelectionRange range = m_selection->range();
    
    // 注意：这里假设 SelectionRange 存储的是 {start, end}，
    // 但实际上我们需要知道哪个是 anchor，哪个是 focus！
    
    // TODO: 需要扩展 Selection 类来追踪 anchor 和 focus
    
    // 临时方案：暂时返回 range.end（假设选区是从左到右）
    return {range.endBlock, range.endOffset};
}
```

### 3.4 需要扩展的类

#### 3.4.1 Selection 类扩展

当前 Selection 类可能只存储了归一化的范围，我们需要扩展它来追踪选择方向：

```cpp
struct SelectionRange
{
    int anchorBlock = -1;      // 锚点块索引
    int anchorOffset = 0;       // 锚点偏移
    int focusBlock = -1;       // 焦点块索引
    int focusOffset = 0;        // 焦点偏移
    
    // ... 现有方法 ...
    
    /**
     * @brief 获取焦点位置（最后一个选中字符的位置）
     */
    CursorPosition focusPosition() const {
        return {focusBlock, focusOffset};
    }
};
```

---

## 4. 更新计划

### 4.1 阶段 1：扩展 Selection 类
**目标**：让 Selection 类能够追踪锚点和焦点

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 1.1 修改 SelectionRange 结构体 | 添加 anchorBlock/Offset 和 focusBlock/Offset | 30 分钟 |
| 1.2 修改 Selection::setRange() | 保存选择时的起点和终点 | 30 分钟 |
| 1.3 修改 Selection::extend() | 更新焦点位置 | 30 分钟 |
| 1.4 添加 Selection::focusPosition() | 获取焦点位置的方法 | 15 分钟 |
| **小计** | | **2 小时** |

### 4.2 阶段 2：完善 FormatController 类
**目标**：添加获取显示样式的方法

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 2.1 添加 getStyleAtPosition() | 获取指定位置的样式 | 30 分钟 |
| 2.2 添加 getSelectionEndPosition() | 获取选区终点位置 | 15 分钟 |
| 2.3 添加 getCurrentDisplayStyle() | 主方法，判断显示逻辑 | 45 分钟 |
| 2.4 单元测试 | 测试各种边界情况 | 1 小时 |
| **小计** | | **2.5 小时** |

### 4.3 阶段 3：修改 MainWindow 类
**目标**：更新样式状态更新流程

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 3.1 修改 updateStyleState() | 调用新的 getCurrentDisplayStyle() | 30 分钟 |
| 3.2 连接 Selection::selectionChanged 信号 | 选区变化时更新显示 | 15 分钟 |
| **小计** | | **45 分钟** |

### 4.4 阶段 4：完善 RibbonBar 类
**目标**：更新显示逻辑

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 4.1 修改 updateFromSelection() | 接受完整的 CharacterStyle 参数 | 30 分钟 |
| 4.2 更新所有样式控件显示 | 字体、字号、粗体、斜体等 | 1 小时 |
| **小计** | | **1.5 小时** |

### 4.5 阶段 5：集成测试
**目标**：完整测试所有场景

| 任务 | 说明 | 预计工作量 |
|------|------|-----------|
| 5.1 无选区场景测试 | 光标移动、直接打字 | 30 分钟 |
| 5.2 有选区场景测试 | 从左到右、从右到左选择 | 45 分钟 |
| 5.3 边界情况测试 | 选区在文档开头/结尾 | 30 分钟 |
| **小计** | | **1.75 小时** |

### 总体时间估算

| 阶段 | 时间 |
|------|------|
| 阶段 1：扩展 Selection | 2 小时 |
| 阶段 2：完善 FormatController | 2.5 小时 |
| 阶段 3：修改 MainWindow | 45 分钟 |
| 阶段 4：完善 RibbonBar | 1.5 小时 |
| 阶段 5：集成测试 | 1.75 小时 |
| **总计** | **8.25 小时（约 1 个工作日）** |

---

## 5. 交互流程图

### 5.1 完整的显示更新流程

```
┌─────────────────────────────────────────────────────────────────┐
│                    触发事件（光标移动/选区变化）                │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  MainWindow::updateStyleState()                                │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 1. 调用 FormatController::getCurrentDisplayStyle()      │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  FormatController::getCurrentDisplayStyle()                   │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 2. 检查是否有选区                                        │  │
│  │    ├─ 有选区：→ 获取焦点位置（Focus）                   │  │
│  │    │         → 目标位置 = 焦点位置 - 1                 │  │
│  │    │         → 获取该位置的样式                          │  │
│  │    │                                                      │  │
│  │    └─ 无选区：→ 获取光标位置                            │  │
│  │              → 目标位置 = 光标位置 - 1                 │  │
│  │              → 获取该位置的样式                          │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  FormatController::getStyleAtPosition()                        │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 3. 验证位置有效性                                        │  │
│  │ 4. 找到对应的 ParagraphBlock                            │  │
│  │ 5. 调用 ParagraphBlock::styleAt()                       │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  返回 CharacterStyle 给 MainWindow                            │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  MainWindow 调用 RibbonBar::updateFromSelection(style)       │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│  RibbonBar::updateFromSelection()                             │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │ 6. 使用 QSignalBlocker 防止信号循环                      │  │
│  │ 7. 更新字体下拉框                                        │  │
│  │ 8. 更新字号下拉框                                        │  │
│  │ 9. 更新粗体按钮状态                                      │  │
│  │ 10. 更新斜体按钮状态                                     │  │
│  │ 11. 更新下划线按钮状态                                   │  │
│  └───────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────────┐
│                    ✅ 工具栏显示更新完成！                        │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 测试用例

### 6.1 测试场景 1：无选区，光标在中间

**测试步骤：**
1. 打开文档，输入 "Hello World"
2. 移动光标到 "Hello" 和 "World" 之间（即空格后）
3. 设置 "Hello" 为粗体，"World" 为普通样式
4. 将光标放在空格后（"World" 前）

**预期结果：**
- 工具栏显示：光标前字符（空格）的样式
- 如果空格是普通样式，则工具栏显示普通样式

---

### 6.2 测试场景 2：有选区，从左到右选择

**测试步骤：**
1. 输入 "ABCDE"
2. 设置 "A" 为普通，"B" 为粗体，"C" 为斜体，"D" 为粗斜体，"E" 为普通
3. 从左到右选择 "BCD"（从 B 开始，到 E 之前结束）

**选区图示：**
```
A [ B C D ] E
  ↑       ↑
Anchor  Focus
         ↑
      最后一个选中字符是 D
```

**预期结果：**
- 工具栏显示：D 的样式（粗斜体）

---

### 6.3 测试场景 3：有选区，从右到左选择

**测试步骤：**
1. 输入 "ABCDE"
2. 设置样式同上
3. 从右到左选择 "BCD"（从 D 开始，到 A 之后结束）

**选区图示：**
```
A [ B C D ] E
    ↑       ↑
  Focus   Anchor
    ↑
最后一个选中字符是 B
```

**预期结果：**
- 工具栏显示：B 的样式（粗体）

---

### 6.4 测试场景 4：选区在文档开头

**测试步骤：**
1. 输入 "Hello"
2. 从左到右选择 "He"
3. 或者从右到左选择 "He"

**预期结果：**
- 从左到右选择：显示第二个字符 'e' 的样式
- 从右到左选择：显示第一个字符 'H' 的样式

---

### 6.5 测试场景 5：选区在文档结尾

**测试步骤：**
1. 输入 "Hello"
2. 选择整个单词 "Hello"

**预期结果：**
- 从左到右选择：显示最后一个字符 'o' 的样式
- 从右到左选择：显示第一个字符 'H' 的样式

---

## 文档信息

- **创建日期**：2026-02-18
- **版本**：v1.0
- **作者**：QtWordEditor 开发团队
- **状态**：待评审
