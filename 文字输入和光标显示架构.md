# 文字输入和光标显示架构详解

## 目录
1. [架构概述](#架构概述)
2. [坐标系统详解](#坐标系统详解)
3. [文字输入流程](#文字输入流程)
4. [光标位置计算](#光标位置计算)
5. [LayoutEngine 的作用](#layoutengine-的作用)
6. [各模块职责](#各模块职责)
7. [实现计划](#实现计划)

---

## 架构概述

### 完整架构图

```
┌─────────────────────────────────────────────────────────────────┐
│                        用户输入层                                │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ DocumentView │  │ QKeyEvent    │  │ QMouseEvent  │     │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘     │
└─────────┼───────────────────┼───────────────────┼────────────┘
          │                   │                   │
          ▼                   ▼                   ▼
┌─────────────────────────────────────────────────────────────────┐
│                     编辑控制层                                  │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │              EditEventHandler                            │  │
│  │  - handleKeyPress()                                      │  │
│  │  - handleMousePress()                                    │  │
│  │  - handleInputMethod()                                   │  │
│  └──────────────┬───────────────────────────────────────────┘  │
└─────────────────┼──────────────────────────────────────────────┘
                  │
                  ▼
        ┌─────────────────┐
        │     Cursor      │
        │  - position()   │
        │  - insertText() │
        │  - moveLeft()   │
        └────────┬────────┘
                 │
         ┌───────┴───────┐
         │               │
         ▼               ▼
┌────────────────┐  ┌──────────────────┐
│   Document     │  │  Command (Undo)  │
│  - Section     │  │  - InsertText    │
│  - Block       │  │  - RemoveText    │
│  - Paragraph   │  └──────────────────┘
└────────┬───────┘
         │
         ▼
┌─────────────────────────────────────┐
│         布局引擎层                    │
│  ┌───────────────────────────────┐  │
│  │        LayoutEngine           │  │
│  │  - layout()                   │  │
│  │  - calculateBlockHeight()     │  │
│  │  - 计算块位置和大小           │  │
│  └───────────────┬───────────────┘  │
└──────────────────┼──────────────────┘
                   │
                   ▼
┌───────────────────────────────────────────────┐
│              图形渲染层                        │
│  ┌─────────────────────────────────────────┐  │
│  │        DocumentScene                    │  │
│  │  - QGraphicsScene                      │  │
│  │  - 管理所有图形项                       │  │
│  └──────────┬─────────────────────────────┘  │
│             │                                  │
│  ┌──────────┴─────────────────────────────┐  │
│  │        DocumentView                     │  │
│  │  - QGraphicsView                       │  │
│  │  - 场景到视图的坐标转换                 │  │
│  └──────────┬─────────────────────────────┘  │
└─────────────┼────────────────────────────────┘
              │
    ┌─────────┴─────────┐
    │                   │
    ▼                   ▼
┌──────────┐     ┌────────────┐
│TextBlock │     │ CursorItem │
│Item      │     │ (闪烁)     │
└──────────┘     └────────────┘
```

---

## 坐标系统详解

### 多层坐标系统

QtWordEditor 包含 5 层坐标系统：

| 坐标系统 | 说明 | 单位 | 范围 |
|---------|------|------|-------|
| **屏幕坐标** | 相对于整个屏幕 | 像素 | 由屏幕决定 |
| **视图坐标** | 相对于 DocumentView 控件 | 像素 | (0,0) 到 (width, height) |
| **场景坐标** | 相对于 DocumentScene | 点（1/72英寸） | 整个文档区域 |
| **页面坐标** | 相对于当前页面 | 点 | (0,0) 到 (pageWidth, pageHeight) |
| **块坐标** | 相对于块的左上角 | 点 | 块内部区域 |

### 坐标转换关系

```
屏幕坐标
   ↓ (QWidget::mapFromGlobal)
视图坐标 (DocumentView)
   ↓ (QGraphicsView::mapToScene)
场景坐标 (DocumentScene)
   ↓ (减去页面偏移)
页面坐标 (Page)
   ↓ (减去块位置)
块坐标 (Block)
   ↓ (QTextLayout)
字符坐标 (Character)
```

### 重要常量

```cpp
// Constants.h 中定义
PAGE_WIDTH = 595.0;    // A4 宽度（点）
PAGE_HEIGHT = 842.0;   // A4 高度（点）
PAGE_MARGIN = 72.0;     // 边距（1 英寸 = 72 点）
```

---

## 文字输入流程

### 完整输入流程图

```
用户按下键盘
    ↓
DocumentView::keyPressEvent()
    ↓
发出 keyPressed(QKeyEvent*) 信号
    ↓
EditEventHandler::handleKeyPress() 接收
    ↓
┌─────────────────────────────────────┐
│ 判断按键类型                         │
├─────────────────────────────────────┤
│ 1. 方向键 (Left/Right/Up/Down)    │
│ 2. 删除键 (Backspace/Delete)       │
│ 3. 回车键 (Return/Enter)           │
│ 4. 普通字符 (A-Z, 0-9, 标点)      │
└─────────────────────────────────────┘
    ↓
    ├─→ 方向键: Cursor::moveLeft() / moveRight() 等
    │       ↓
    │   更新 m_position
    │       ↓
    │   发出 positionChanged() 信号
    │
    ├─→ 删除键: Cursor::deletePreviousChar() / deleteNextChar()
    │       ↓
    │   创建并执行 RemoveTextCommand
    │       ↓
    │   Document 更新
    │       ↓
    │   LayoutEngine::layout() 重新布局
    │
    └─→ 普通字符: Cursor::insertText(text, style)
            ↓
        创建并执行 InsertTextCommand
            ↓
        ParagraphBlock::insert(position, text, style)
            ↓
        更新 Span 列表
            ↓
        发出 textChanged() 信号
            ↓
        LayoutEngine::layout() 重新布局
            ↓
        DocumentScene 重建
            ↓
        TextBlockItem::updateBlock() 更新显示
            ↓
        Cursor 位置更新 +1
            ↓
        CursorItem 更新显示位置
```

### EditEventHandler 的关键职责

```cpp
// src/editcontrol/handlers/EditEventHandler.cpp
bool EditEventHandler::handleKeyPress(QKeyEvent *event)
{
    switch (event->key()) {
    case Qt::Key_Left:
        m_cursor->moveLeft();
        break;
    case Qt::Key_Right:
        m_cursor->moveRight();
        break;
    case Qt::Key_Backspace:
        m_cursor->deletePreviousChar();
        break;
    case Qt::Key_Delete:
        m_cursor->deleteNextChar();
        break;
    default:
        if (!event->text().isEmpty()) {
            CharacterStyle style;
            m_cursor->insertText(event->text(), style);
        }
        break;
    }
}
```

---

## 光标位置计算

### 光标位置的双重表示

光标位置有两种表示方式：

#### 1. 逻辑位置（CursorPosition）
```cpp
struct CursorPosition {
    int blockIndex;   // 在哪个块中
    int offset;       // 块内的字符偏移量
};
```

#### 2. 视觉位置（QPointF）
```cpp
QPointF visualPos;  // 场景坐标，用于绘制 CursorItem
```

### 从逻辑位置到视觉位置的计算

```
CursorPosition (blockIndex, offset)
    ↓
1. 获取 Block 对象
    ↓
2. 获取 Block 在场景中的 Y 位置 (block->y())
    ↓
3. 获取 Block 内部文本的布局
    ↓
4. 使用 QTextLayout 计算第 offset 个字符的 X 坐标
    ↓
5. 组合 Y 坐标和 X 坐标
    ↓
得到 QPointF (x, y)
```

### QTextLayout 的使用

Qt 提供了强大的 QTextLayout 来处理文本布局：

```cpp
// 示例：计算字符位置
QTextLayout textLayout(text, font);
textLayout.beginLayout();
QTextLine line = textLayout.createLine();
line.setLineWidth(maxWidth);
line.setPosition(QPointF(0, 0));
textLayout.endLayout();

// 获取第 n 个字符的位置
QPointF charPos = line.cursorToX(n);
```

### 从视觉位置到逻辑位置（点击定位）

```
用户点击场景位置 (sceneX, sceneY)
    ↓
1. 查找点击在哪个 Page 上
    ↓
2. 查找点击在哪个 Block 上
    ↓
3. 计算在 Block 内的相对坐标 (relX, relY)
    ↓
4. 使用 QTextLayout::xToCursor(relX) 获取字符偏移
    ↓
得到 CursorPosition (blockIndex, offset)
```

---

## LayoutEngine 的作用

### LayoutEngine 的核心职责

| 功能 | 说明 |
|------|------|
| **分页** | 将 Block 分配到不同的 Page |
| **计算块高度** | 根据文本内容计算 Block 需要的高度 |
| **计算块位置** | 计算每个 Block 在场景中的 Y 坐标 |
| **触发重绘** | 布局完成后发出信号，通知 Scene 更新 |

### LayoutEngine 与文字输入的关系

```
用户输入文字
    ↓
ParagraphBlock 内容更新
    ↓
发出 textChanged() 信号
    ↓
Document 发出 documentChanged() 信号
    ↓
LayoutEngine::layout() 被调用
    ↓
1. 清空所有 Page
    ↓
2. 遍历所有 Block
    ↓
3. calculateBlockHeight(block, maxWidth)
   ├─→ 获取 Block 的文本
   ├─→ 使用 QTextLayout 计算高度
   └─→ 缓存高度结果
    ↓
4. 使用 PageBuilder 分配 Block 到 Page
    ↓
5. 设置每个 Block 的 y() 位置
    ↓
6. 发出 layoutChanged() 信号
    ↓
DocumentScene::rebuildFromDocument()
    ↓
更新所有图形项
    ↓
用户看到更新后的文档
```

### calculateBlockHeight 的实现要点

```cpp
qreal LayoutEngine::calculateBlockHeight(Block *block, qreal maxWidth)
{
    ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
    if (!paraBlock)
        return 20.0;

    // 1. 获取段落样式
    ParagraphStyle style = paraBlock->paragraphStyle();

    // 2. 获取文本和字符样式
    QString text = paraBlock->text();
    QList<Span> spans = paraBlock->spans();

    // 3. 创建 QTextLayout
    QTextLayout textLayout(text);

    // 4. 应用字符样式到不同范围
    for (const Span &span : spans) {
        QTextCharFormat format;
        format.setFont(span.style().font());
        format.setForeground(span.style().textColor());
        textLayout.setFormats({{span.start(), span.length(), format}});
    }

    // 5. 应用段落样式（缩进、对齐等）
    qreal leftIndent = style.leftIndent() + style.firstLineIndent();
    qreal rightIndent = style.rightIndent();

    // 6. 执行布局
    textLayout.beginLayout();
    qreal y = 0;
    while (true) {
        QTextLine line = textLayout.createLine();
        if (!line.isValid())
            break;
        line.setLineWidth(maxWidth - leftIndent - rightIndent);
        line.setPosition(QPointF(leftIndent, y));
        y += line.height() + style.lineSpacing();
    }
    textLayout.endLayout();

    // 7. 计算总高度
    qreal totalHeight = y;
    totalHeight += style.spaceBefore();
    totalHeight += style.spaceAfter();

    return totalHeight;
}
```

---

## 各模块职责

### 1. Document（文档模型）
- **职责**：存储文档内容
- **包含**：多个 Section
- **信号**：documentChanged(), blockAdded(), blockRemoved()

### 2. ParagraphBlock（段落块）
- **职责**：存储单个段落的文本和样式
- **包含**：文本 + Span 列表 + 段落样式
- **方法**：insert(), remove(), setText()
- **信号**：textChanged()

### 3. Span（文本跨度）
- **职责**：表示具有相同字符样式的一段文本
- **包含**：start, length, CharacterStyle

### 4. Cursor（光标）
- **职责**：管理插入点位置
- **包含**：CursorPosition（逻辑位置）
- **方法**：moveLeft(), insertText(), deletePreviousChar()
- **信号**：positionChanged()

### 5. EditEventHandler（编辑事件处理器）
- **职责**：将用户输入转换为编辑操作
- **输入**：QKeyEvent, QMouseEvent
- **输出**：调用 Cursor 的方法

### 6. LayoutEngine（布局引擎）
- **职责**：计算块的位置和大小，分页
- **输入**：Document
- **输出**：Page 列表，Block 的 y() 和 height()
- **关键方法**：layout(), calculateBlockHeight()

### 7. DocumentScene（文档场景）
- **职责**：管理所有图形项
- **继承**：QGraphicsScene
- **包含**：PageItem, TextBlockItem, CursorItem, SelectionItem
- **方法**：rebuildFromDocument(), updateCursor()

### 8. DocumentView（文档视图）
- **职责**：显示场景，处理用户输入
- **继承**：QGraphicsView
- **功能**：缩放、滚动、坐标转换
- **信号**：keyPressed(), mousePressed(), mousePositionChanged()

### 9. TextBlockItem（文本块图形项）
- **职责**：渲染 ParagraphBlock
- **继承**：BaseBlockItem → QGraphicsItem
- **包含**：QGraphicsTextItem 或自定义绘制
- **方法**：updateBlock()

### 10. CursorItem（光标图形项）
- **职责**：渲染闪烁的光标
- **继承**：QGraphicsItem
- **功能**：定时器实现闪烁

---

## 实现计划

### 阶段 1：完善 Cursor 类
1. ✅ 实现 Cursor::insertText()
2. ✅ 实现 Cursor::deletePreviousChar()
3. ✅ 实现 Cursor::deleteNextChar()
4. ✅ 实现所有移动方法（moveLeft, moveRight 等）

### 阶段 2：完善 ParagraphBlock 类
1. ✅ 实现 insert() 方法
2. ✅ 实现 remove() 方法
3. ✅ 确保 Span 管理正确

### 阶段 3：实现命令系统
1. ✅ InsertTextCommand
2. ✅ RemoveTextCommand
3. ✅ 集成到 QUndoStack

### 阶段 4：完善 LayoutEngine
1. ❌ 实现完整的 layout() 方法
2. ❌ 实现 calculateBlockHeight() 使用 QTextLayout
3. ❌ 实现分页逻辑

### 阶段 5：完善图形渲染
1. ❌ TextBlockItem 使用 QTextLayout 渲染
2. ❌ CursorItem 根据 CursorPosition 计算位置
3. ❌ 实时更新

### 阶段 6：鼠标交互
1. ❌ 点击定位光标
2. ❌ 拖拽选择文本

---

## 关键数据结构总结

### ParagraphBlock 的内部结构
```
ParagraphBlock
├── text: "Hello World"
├── m_spans: [
│   ├── Span { start=0, length=5, style={bold=true} }  // "Hello"
│   └── Span { start=5, length=6, style={bold=false} } // " World"
│ ]
└── m_paragraphStyle: { alignment=AlignLeft, ... }
```

### CursorPosition 的示例
```
文本: "Hello| World"
         ↑
         光标在第 5 个字符后

CursorPosition {
    blockIndex = 0,   // 在第一个块
    offset = 5        // 偏移 5 个字符
}
```

---

## 总结

文字输入和光标显示是一个多层协作的系统：

1. **输入层**：DocumentView 捕获输入
2. **控制层**：EditEventHandler 处理输入，Cursor 管理位置
3. **模型层**：Document、ParagraphBlock 存储内容
4. **布局层**：LayoutEngine 计算位置和大小（关键！）
5. **渲染层**：DocumentScene、TextBlockItem、CursorItem 显示

**LayoutEngine 是连接模型和视图的桥梁**，它负责：
- 将逻辑位置（字符偏移）转换为视觉位置（像素坐标）
- 计算每个块需要的高度
- 处理分页
- 触发整个界面的更新

---

## 输入文字和显示光标的详细实现步骤

基于对当前程序的分析，要实现输入文字和看到光标闪烁，需要按以下步骤进行：

---

### 阶段一：完善 DocumentScene 的重建功能

#### 步骤 1：完善 DocumentScene::rebuildFromDocument() 方法
**文件**：`src/graphics/scene/DocumentScene.cpp`

**当前问题**：该方法目前只清空了场景，没有实际重建任何图形项。

**需要实现**：
1. 从 Document 中遍历所有 Section
2. 从每个 Section 中遍历所有 Page
3. 为每个 Page 创建 PageItem 并添加到场景
4. 从每个 Page 中遍历所有 Block
5. 为每个 Block 创建对应的 TextBlockItem
6. 设置每个 Block 的 boundingRect（位置和大小）
7. 将 TextBlockItem 添加到场景并调用 updateBlock()
8. 保持 m_blockItems 的映射关系

**关键代码参考**：
```cpp
void DocumentScene::rebuildFromDocument()
{
    clear();
    m_blockItems.clear();
    m_pageItems.clear();
    qDebug() << "DocumentScene::rebuildFromDocument()";

    if (!m_document)
        return;

    for (int sectionIdx = 0; sectionIdx < m_document->sectionCount(); ++sectionIdx) {
        Section *section = m_document->section(sectionIdx);
        if (!section)
            continue;

        for (int pageIdx = 0; pageIdx < section->pageCount(); ++pageIdx) {
            Page *page = section->page(pageIdx);
            if (!page)
                continue;

            addPage(page);

            for (int blockIdx = 0; blockIdx < page->blockCount(); ++blockIdx) {
                Block *block = page->block(blockIdx);
                if (!block)
                    continue;

                if (qobject_cast<ParagraphBlock*>(block)) {
                    TextBlockItem *textItem = new TextBlockItem(
                        qobject_cast<ParagraphBlock*>(block));
                    
                    qreal pageY = m_pageItems.size() > 1 ? 
                        m_pageItems[m_pageItems.size() - 2]->y() : 0.0;
                    
                    textItem->setPos(0, pageY);
                    textItem->updateBlock();
                    addItem(textItem);
                    m_blockItems[block] = textItem;
                }
            }
        }
    }
}
```

---

### 阶段二：完善 TextBlockItem 的显示

#### 步骤 2：改进 TextBlockItem::updateBlock() 方法
**文件**：`src/graphics/items/TextBlockItem.cpp`

**当前问题**：只设置了纯文本，没有正确设置位置和字体。

**需要实现**：
1. 获取 ParagraphBlock 的文本
2. 设置 QGraphicsTextItem 的文本
3. 获取 Block 的 boundingRect 并设置位置
4. 设置合适的字体大小（12pt）
5. 确保文本在正确的位置显示

**关键代码参考**：
```cpp
void TextBlockItem::updateBlock()
{
    ParagraphBlock *para = qobject_cast<ParagraphBlock*>(m_block);
    if (!para)
        return;

    m_textItem->setPlainText(para->text());
    
    QFont font;
    font.setPointSize(12);
    m_textItem->setFont(font);
    
    QRectF rect = m_block->boundingRect();
    m_textItem->setPos(rect.topLeft());
}
```

---

### 阶段三：确保光标显示和闪烁

#### 步骤 3：在 DocumentScene 重建后初始化光标
**文件**：`src/ui/mainwindow/MainWindow.cpp`

**当前问题**：场景重建后，光标可能没有被重新创建或位置没有更新。

**需要实现**：
1. 在 newDocument() 调用之后
2. 在 m_scene->rebuildFromDocument() 调用之后
3. 调用 m_scene->updateCursor() 来初始化光标
4. 确保光标位置是 (0, 0) 或正确的起始位置

**关键代码参考**：
```cpp
// 在 MainWindow::setupUi() 中或 newDocument() 之后
m_cursor->setPosition(0, 0);
QPointF initialPos = calculateCursorVisualPosition(m_cursor->position());
m_scene->updateCursor(initialPos, 20.0);
```

#### 步骤 4：连接 ParagraphBlock 的 textChanged 信号
**文件**：`src/ui/mainwindow/MainWindow.cpp`

**当前问题**：虽然我们之前连接了，但需要确保在每次重建场景后重新连接。

**需要实现**：
1. 在 newDocument() 中创建 ParagraphBlock 时连接信号
2. 在信号处理函数中：
   - 调用 m_scene->rebuildFromDocument() 重建场景
   - 重新计算光标位置
   - 调用 m_scene->updateCursor() 更新光标

**关键代码参考**：
```cpp
connect(paraBlock, &ParagraphBlock::textChanged, this, [this]() {
    m_scene->rebuildFromDocument();
    QPointF visualPos = calculateCursorVisualPosition(m_cursor->position());
    m_scene->updateCursor(visualPos, 20.0);
});
```

---

### 阶段四：确保 DocumentView 获得焦点并处理输入

#### 步骤 5：确保 DocumentView 获得焦点
**文件**：`src/ui/mainwindow/MainWindow.cpp`

**当前问题**：虽然调用了 m_view->setFocus()，但可能时机不对。

**需要实现**：
1. 在所有初始化完成后调用 m_view->setFocus()
2. 确保在 showEvent() 中也设置焦点
3. 可能需要调用 m_view->activateWindow()

**关键代码参考**：
```cpp
// 在 setupUi() 的最后
m_view->setFocus();
m_view->activateWindow();
```

#### 步骤 6：验证 DocumentView 的 keyPressEvent 正确转发
**文件**：`src/graphics/view/DocumentView.cpp`

**当前问题**：需要确保按键事件被正确转发到 EditEventHandler。

**需要验证**：
1. DocumentView::keyPressEvent() 发出 keyPressed() 信号
2. 该信号连接到 EditEventHandler::handleKeyPress()
3. EditEventHandler 正确处理普通字符输入

---

### 阶段五：完善 calculateCursorVisualPosition 方法

#### 步骤 7：改进光标位置计算
**文件**：`src/ui/mainwindow/MainWindow.cpp`

**当前问题**：需要确保从 CursorPosition 计算出正确的视觉坐标。

**需要实现**：
1. 获取 Block 的 boundingRect
2. 使用 QFontMetrics 计算光标前文本的宽度
3. 考虑页面的 Y 偏移
4. 确保返回的坐标是场景坐标

**关键代码参考**：
```cpp
QPointF MainWindow::calculateCursorVisualPosition(const CursorPosition &pos)
{
    if (!m_document)
        return QPointF(0, 0);

    Block *block = m_document->block(pos.blockIndex);
    if (!block)
        return QPointF(0, 0);

    QRectF rect = block->boundingRect();
    qreal x = rect.left();
    qreal y = rect.top();

    ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
    if (paraBlock) {
        QString text = paraBlock->text();
        int charOffset = qMin(pos.offset, text.length());

        QFont font;
        font.setPointSize(12);
        QFontMetrics fm(font);

        QString textBeforeCursor = text.left(charOffset);
        x += fm.horizontalAdvance(textBeforeCursor);
    }

    return QPointF(x, y);
}
```

---

### 阶段六：验证和测试

#### 步骤 8：编译并测试
1. 编译项目：`cmake --build cmake-build-debug --config Debug`
2. 运行程序：`.\cmake-build-debug\QtWordEditor.exe`
3. 测试步骤：
   - 查看是否有页面显示
   - 查看是否有光标闪烁
   - 点击页面确保 DocumentView 有焦点
   - 输入一些文字（如 "Hello World"）
   - 使用方向键移动光标
   - 使用 Backspace 删除文字
   - 检查文字是否正确显示
   - 检查光标是否正确跟随

---

### 关键检查点

在实现过程中，需要检查以下关键点：

1. **DocumentScene::rebuildFromDocument()** - 是否真正重建了图形项
2. **TextBlockItem::updateBlock()** - 是否正确设置了文本和位置
3. **DocumentScene::updateCursor()** - 是否被调用，CursorItem 是否被添加到场景
4. **ParagraphBlock::textChanged** - 信号是否被正确连接和处理
5. **DocumentView::keyPressEvent()** - 按键是否被正确转发
6. **Cursor::insertText()** - 是否正确执行 InsertTextCommand
7. **calculateCursorVisualPosition()** - 坐标计算是否正确

---

### 调试技巧

如果遇到问题，可以使用以下调试技巧：

1. **添加 qDebug() 输出** - 在关键方法中添加调试输出
2. **检查信号连接** - 确认所有信号都正确连接
3. **验证对象是否为空** - 在使用指针前检查是否为 nullptr
4. **分步测试** - 先测试光标显示，再测试文字输入
5. **使用 Qt Creator 调试器** - 设置断点查看变量值

---

### 预期结果

完成所有步骤后，应该能够：
1. 看到一个空白的 A4 页面
2. 看到一个闪烁的竖线光标在页面左上角
3. 点击页面后能够输入文字
4. 输入的文字能够正确显示在页面上
5. 光标能够跟随文字输入移动
6. 方向键能够移动光标
7. Backspace 能够删除文字
8. 撤销/重做功能能够正常工作
