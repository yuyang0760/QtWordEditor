# QtWordEditor 样式按钮点击流程设计文档

**日期**: 2026-02-19  
**作者**: 开发团队

---

## 一、概述

本文档详细描述了在 QtWordEditor 中，当选中文本并点击工具栏样式按钮（加粗、斜体、下划线）时的完整执行流程。

---

## 二、核心组件与文件

| 组件 | 文件路径 | 职责 |
|------|---------|------|
| RibbonBar | `include/ui/ribbon/RibbonBar.h`<br>`src/ui/ribbon/RibbonBar.cpp` | 工具栏 UI，发出按钮点击信号 |
| MainWindow | `include/ui/mainwindow/MainWindow.h`<br>`src/ui/mainwindow/MainWindow.cpp` | 连接信号与槽，处理按钮点击逻辑 |
| FormatController | `include/editcontrol/formatting/FormatController.h`<br>`src/editcontrol/formatting/FormatController.cpp` | 格式控制核心，检查选区状态并应用样式 |
| ParagraphBlock | `include/core/document/ParagraphBlock.h`<br>`src/core/document/ParagraphBlock.cpp` | 段落块，执行 Span 分割与样式设置 |
| SetCharacterStyleCommand | `include/core/commands/SetCharacterStyleCommand.h`<br>`src/core/commands/SetCharacterStyleCommand.cpp` | 样式命令，支持撤销/重做 |

---

## 三、完整流程（以加粗按钮为例）

### 3.1 总览流程图

```
用户点击加粗按钮
      ↓
RibbonBar::boldChanged 信号发出
      ↓
MainWindow 的 Lambda 槽函数被调用
      ↓
    ┌───────────────┐
    │ 有选区吗？      │
    └───────┬───────┘
            │
     ┌──────┴──────┐
     │ 是          │ 否
     ↓             ↓
调用 isSelectionAllBold()   根据 getCurrentDisplayStyle() 切换
     ↓             ↓
┌──────────────────────┐  设置当前输入样式
│ 选区内全部加粗？      │
└──────────┬───────────┘
           │
    ┌──────┴──────┐
    │ 是          │ 否
    ↓             ↓
设置为 false    设置为 true
(取消加粗)       (加粗)
     ↓             ↓
FormatController::setBold(newBold)
     ↓
FormatController::applyCharacterStyle(style)
     ↓
遍历选中的块
     ↓
创建 SetCharacterStyleCommand
     ↓
推入 UndoStack
     ↓
ParagraphBlock::setStyle() 被调用
     ↓
分割 Span，应用样式，合并相邻 Span
     ↓
发出 textChanged() 信号
     ↓
TextBlockItem 更新显示
     ↓
MainWindow::updateStyleState() 更新工具栏状态
```

---

### 3.2 详细步骤说明

#### 步骤 1：用户点击加粗按钮

用户在 RibbonBar 工具栏上点击加粗按钮。

---

#### 步骤 2：RibbonBar 发出信号

**文件**: `src/ui/ribbon/RibbonBar.cpp`

RibbonBar 的加粗按钮的 `toggled` 信号触发，发出 `boldChanged` 信号。

---

#### 步骤 3：MainWindow 槽函数被调用

**文件**: `src/ui/mainwindow/MainWindow.cpp:199-233`

```cpp
connect(m_ribbonBar, &RibbonBar::boldChanged,
        this, [this](bool /* bold */) {
    qDebug() << "MainWindow: 加粗按钮被点击";
    
    CharacterStyle style;
    if (m_selection->isEmpty()) {
        // ========== 无选区的情况 ==========
        CharacterStyle currentStyle = m_formatController->getCurrentDisplayStyle();
        bool newBold = !currentStyle.bold();
        style.setBold(newBold);
        m_formatController->setCurrentInputStyle(style);
    } else {
        // ========== 有选区的情况 ==========
        bool allBold = m_formatController->isSelectionAllBold();
        
        bool newBold;
        if (allBold) {
            // 选区内全部都是加粗 → 取消加粗
            newBold = false;
        } else {
            // 选区内不一致或未加粗 → 设置为加粗
            newBold = true;
        }
        
        style.setBold(newBold);
        m_formatController->setBold(newBold);
    }
    updateStyleState();
});
```

**分支 A：无选区**
- 调用 `FormatController::getCurrentDisplayStyle()` 获取当前光标位置前一个字符的样式
- 取反后，调用 `FormatController::setCurrentInputStyle()` 设置新输入样式
- 调用 `MainWindow::updateStyleState()` 更新工具栏

**分支 B：有选区**
- 调用 `FormatController::isSelectionAllBold()` 检查选区内是否全部加粗
  - 如果 `allBold == true` → 设置为 `false`（取消加粗）
  - 如果 `allBold == false` → 设置为 `true`（加粗）
- 调用 `FormatController::setBold(newBold)` 应用样式
- 调用 `MainWindow::updateStyleState()` 更新工具栏

---

#### 步骤 4：FormatController::setBold()

**文件**: `src/editcontrol/formatting/FormatController.cpp:105-110`

```cpp
void FormatController::setBold(bool bold)
{
    CharacterStyle style;
    style.setBold(bold);
    applyCharacterStyle(style);
}
```

- 创建一个新的 `CharacterStyle` 对象
- 设置该对象的 `bold` 属性
- 调用 `applyCharacterStyle(style)` 应用样式

---

#### 步骤 5：FormatController::applyCharacterStyle()

**文件**: `src/editcontrol/formatting/FormatController.cpp:30-79`

```cpp
void FormatController::applyCharacterStyle(const CharacterStyle &style)
{
    if (!m_document || !m_selection)
        return;
    
    SelectionRange range = m_selection->range();
    if (range.isEmpty())
        return;
    
    range.normalize();
    
    // 遍历选择范围内的每个块
    for (int blockIndex = range.startBlock; blockIndex <= range.endBlock; ++blockIndex) {
        Block *block = m_document->block(blockIndex);
        if (!block)
            continue;
        
        ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
        if (!paraBlock)
            continue;
        
        // 计算当前块的起始和结束偏移量
        int startOffset = (blockIndex == range.startBlock) ? range.startOffset : 0;
        int endOffset = (blockIndex == range.endBlock) ? range.endOffset : paraBlock->length();
        
        if (startOffset >= endOffset)
            continue;
        
        // 创建并推入命令
        SetCharacterStyleCommand *cmd = new SetCharacterStyleCommand(
            m_document, blockIndex, startOffset, endOffset, style);
        m_document->undoStack()->push(cmd);
    }
}
```

- 规范化选区范围
- 遍历选区内的每个块
- 对每个块：
  - 计算该块内的起始和结束偏移
  - 创建 `SetCharacterStyleCommand` 命令
  - 将命令推入文档的撤销堆栈

---

#### 步骤 6：SetCharacterStyleCommand::redo()

**文件**: `src/core/commands/SetCharacterStyleCommand.cpp`

命令推入撤销堆栈后，会立即执行 `redo()`：
- 调用 `ParagraphBlock::setStyle(start, length, style)`
- 保存旧样式以便后续撤销

---

#### 步骤 7：ParagraphBlock::setStyle()

**文件**: `src/core/document/ParagraphBlock.cpp:100-263`

这是核心的样式应用逻辑！

```
输入：start, length, style
      ↓
计算 end = start + length
      ↓
找到起始和结束的 Span
      ↓
    ┌──────────────────┐
    │ 在同一个 Span 内？  │
    └────────┬─────────┘
             │
    ┌────────┴────────┐
    │ 是              │ 否
    ↓                 ↓
分割成三个部分       处理起始 Span
before/middle/after    ──────────────────
                       分割成 before/after
                       before 用原始样式
                       after 用合并后的样式
                       ↓
                    处理中间 Span（完全在选区内）
                    直接用合并后的样式修改
                       ↓
                    处理结束 Span
                       ──────────────────
                       分割成 before/after
                       before 用合并后的样式
                       after 用原始样式
                       ↓
                    合并相邻的相同样式的 Span
                       ↓
                    发出 textChanged() 信号
```

**核心逻辑**：
1. 如果选区在同一个 Span 内：
   - 分割成三个部分：before（选区前）、middle（选区内）、after（选区后）
   - before 和 after 保持原始样式
   - middle 使用 `originalStyle.mergeWith(style)` 合并后的样式

2. 如果选区跨多个 Span：
   - **起始 Span**：分割成 before（选区前）和 after（选区后）
     - before 保持原始样式
     - after 使用合并后的样式
   - **中间 Span**（完全在选区内）：直接使用合并后的样式修改
   - **结束 Span**：分割成 before（选区内）和 after（选区外）
     - before 使用合并后的样式
     - after 保持原始样式
   - **合并**：合并相邻的相同样式的 Span

3. 最后发出 `textChanged()` 信号

---

#### 步骤 8：TextBlockItem 更新

**文件**: `src/graphics/items/TextBlockItem.cpp`

当 `ParagraphBlock` 发出 `textChanged()` 信号时：
- `TextBlockItem::updateBlock()` 被调用
- `applyRichTextFromBlock()` 重新构建富文本
- 使用 `QTextDocument` 和 `QTextCursor` 正确应用所有样式
- 界面显示更新

---

#### 步骤 9：MainWindow::updateStyleState()

**文件**: `src/ui/mainwindow/MainWindow.cpp:455-522`

最后调用 `updateStyleState()` 更新工具栏状态：
- 调用 `FormatController::getCurrentDisplayStyle()` 获取应该显示的样式
- 调用 `FormatController::getSelectionStyleConsistency()` 获取各属性的一致性
- 调用 `RibbonBar::updateFromSelection()` 更新工具栏按钮状态

---

## 四、各种情况详细说明

### 4.1 情况 1：无选区，点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查选区为空 |
| 2 | 调用 `getCurrentDisplayStyle()` 获取光标前一个字符的样式 |
| 3 | 取反（如果当前是 false，变成 true；反之亦然） |
| 4 | 调用 `setCurrentInputStyle()` 设置新输入样式 |
| 5 | 调用 `updateStyleState()` 更新工具栏 |

**结果**：后续输入的文字会使用新的加粗状态

---

### 4.2 情况 2：单个 Span 内选择，未加粗，点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查有选区 |
| 2 | 调用 `isSelectionAllBold()` → 返回 false |
| 3 | 设置为 true（加粗） |
| 4 | 调用 `applyCharacterStyle()` |
| 5 | 创建命令，推入撤销堆栈 |
| 6 | `ParagraphBlock::setStyle()` 分割 Span，应用样式 |
| 7 | 发出 `textChanged()`，界面更新 |
| 8 | 调用 `updateStyleState()`，工具栏加粗按钮亮起 |

**结果**：选区内文字加粗，工具栏显示加粗

---

### 4.3 情况 3：单个 Span 内选择，已加粗，点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查有选区 |
| 2 | 调用 `isSelectionAllBold()` → 返回 true |
| 3 | 设置为 false（取消加粗） |
| 4 | 调用 `applyCharacterStyle()` |
| 5 | 创建命令，推入撤销堆栈 |
| 6 | `ParagraphBlock::setStyle()` 分割 Span，应用样式 |
| 7 | 发出 `textChanged()`，界面更新 |
| 8 | 调用 `updateStyleState()`，工具栏加粗按钮熄灭 |

**结果**：选区内文字取消加粗，工具栏不显示加粗

---

### 4.4 情况 4：跨多个 Span 选择，部分加粗，点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查有选区 |
| 2 | 调用 `isSelectionAllBold()` → 检查所有重叠的 Span，发现有非加粗的，返回 false |
| 3 | 设置为 true（加粗） |
| 4 | 调用 `applyCharacterStyle()` |
| 5 | 创建命令，推入撤销堆栈 |
| 6 | `ParagraphBlock::setStyle()` 处理跨 Span 情况：<br>  - 起始 Span：分割，after 部分加粗<br>  - 中间 Span：全部加粗<br>  - 结束 Span：分割，before 部分加粗<br>  - 合并相邻 Span |
| 7 | 发出 `textChanged()`，界面更新 |
| 8 | 调用 `updateStyleState()`，工具栏加粗按钮亮起 |

**结果**：选区内所有文字都加粗，工具栏显示加粗

---

### 4.5 情况 5：跨多个 Span 选择，已全部加粗，再次点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查有选区 |
| 2 | 调用 `isSelectionAllBold()` → 检查所有重叠的 Span，全部都是加粗，返回 true |
| 3 | 设置为 false（取消加粗） |
| 4 | 调用 `applyCharacterStyle()` |
| 5 | 创建命令，推入撤销堆栈 |
| 6 | `ParagraphBlock::setStyle()` 处理跨 Span 情况：<br>  - 起始 Span：分割，after 部分取消加粗<br>  - 中间 Span：全部取消加粗<br>  - 结束 Span：分割，before 部分取消加粗<br>  - 合并相邻 Span |
| 7 | 发出 `textChanged()`，界面更新 |
| 8 | 调用 `updateStyleState()`，工具栏加粗按钮熄灭 |

**结果**：选区内所有文字都取消加粗，工具栏不显示加粗

---

## 五、关键方法说明

### 5.1 FormatController::isSelectionAllBold()

**文件**: `src/editcontrol/formatting/FormatController.cpp:524-568`

```cpp
bool FormatController::isSelectionAllBold() const
{
    if (!m_selection || m_selection->isEmpty()) {
        return false;
    }
    
    SelectionRange range = m_selection->range();
    
    // 检查是否跨多个块
    if (range.startBlock != range.endBlock) {
        return false;
    }
    
    if (range.startBlock < 0) {
        return false;
    }
    
    Block *block = m_document->block(range.startBlock);
    ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
    if (!paraBlock) {
        return false;
    }
    
    // 收集所有与选区重叠的 Span
    int currentOffset = 0;
    for (int i = 0; i < paraBlock->spanCount(); ++i) {
        const Span &span = paraBlock->span(i);
        int spanStart = currentOffset;
        int spanEnd = spanStart + span.text().length();
        
        // 检查 span 是否与选区重叠
        if (!(spanEnd <= range.startOffset || spanStart >= range.endOffset)) {
            // 如果有一个 span 的粗体是 false，那么就返回 false
            if (!span.style().bold()) {
                return false;
            }
        }
        
        currentOffset = spanEnd;
    }
    
    return true;
}
```

**职责**：检查选区内所有字符的粗体是否都为 true

**逻辑**：
1. 如果无选区或跨多个块 → 返回 false
2. 遍历段落的所有 Span
3. 对于每个与选区重叠的 Span：
   - 如果该 Span 的 `bold` 是 false → 立即返回 false
4. 如果所有重叠 Span 的 `bold` 都是 true → 返回 true

---

### 5.2 CharacterStyle::mergeWith()

**文件**: `src/core/document/CharacterStyle.cpp:259-293`

```cpp
CharacterStyle CharacterStyle::mergeWith(const CharacterStyle &other) const
{
    CharacterStyle result = *this;
    
    // 只合并另一个样式中已显式设置的属性
    if (other.isPropertySet(CharacterStyleProperty::FontFamily)) {
        result.setFontFamily(other.fontFamily());
    }
    if (other.isPropertySet(CharacterStyleProperty::FontSize)) {
        result.setFontSize(other.fontSize());
    }
    if (other.isPropertySet(CharacterStyleProperty::Bold)) {
        result.setBold(other.bold());
    }
    if (other.isPropertySet(CharacterStyleProperty::Italic)) {
        result.setItalic(other.italic());
    }
    if (other.isPropertySet(CharacterStyleProperty::Underline)) {
        result.setUnderline(other.underline());
    }
    // ... 其他属性
    
    return result;
}
```

**职责**：将另一个样式合并到当前样式

**逻辑**：
- 保留当前样式的所有属性
- 只覆盖另一个样式中**已显式设置**的属性
- 使用 `isPropertySet()` 来判断某个属性是否已设置

---

## 六、总结

| 功能 | 说明 |
|------|------|
| **工具栏显示** | 单个 Span 显示该 Span 样式，跨 Span 显示空状态 |
| **按钮点击（无选区）** | 根据当前光标位置样式切换，影响后续输入 |
| **按钮点击（有选区）** | 根据选区内实际状态决定：<br> - 全部已设置 → 取消<br> - 未全部设置 → 设置 |
| **样式应用** | 使用 `ParagraphBlock::setStyle()` 分割和合并 Span |
| **撤销/重做** | 使用命令模式，支持完整的撤销/重做 |
