# QtWordEditor 样式按钮点击流程设计文档

**日期**: 2026-02-19  
**作者**: 开发团队  
**版本**: v2.0 (基于实际代码更新)

---

## 一、概述

本文档详细描述了在 QtWordEditor 中，当选中文本并点击工具栏样式按钮（加粗、斜体、下划线）时的完整执行流程。

---

## 二、核心组件与文件

| 组件 | 文件路径 | 职责 |
|------|---------|------|
| RibbonBar | `include/ui/ribbon/RibbonBar.h`<br>`src/ui/ribbon/RibbonBar.cpp` | 工具栏 UI，发出按钮点击信号 |
| MainWindow | `include/ui/mainwindow/MainWindow.h`<br>`src/ui/mainwindow/MainWindow.cpp` | 连接信号与槽，处理按钮点击逻辑 |
| FormatController | `include/editcontrol/formatting/FormatController.h`<br>`src/editcontrol/formatting/FormatController.cpp` | 格式控制核心，检查选区状态并应用样式 |
| ParagraphBlock | `include/core/document/ParagraphBlock.h`<br>`src/core/document/ParagraphBlock.cpp` | 段落块，执行 Span 分割与样式设置 |
| SetCharacterStyleCommand | `include/core/commands/SetCharacterStyleCommand.h`<br>`src/core/commands/SetCharacterStyleCommand.cpp` | 样式命令，支持撤销/重做 |

---

## 三、完整流程（以加粗按钮为例）

### 3.1 总览流程图

```
用户点击加粗按钮
      ↓
RibbonBar 的 QAction::triggered 信号触发
      ↓
RibbonBar 的 Lambda 槽函数执行
      ↓
QSignalBlocker 阻止 setChecked 触发信号
      ↓
发出 boldChanged(false) 信号（参数值被忽略）
      ↓
MainWindow 的 Lambda 槽函数被调用
      ↓
    ┌───────────────┐
    │ 有选区吗？      │
    └───────┬───────┘
            │
     ┌──────┴──────┐
     │ 是          │ 否
     ↓             ↓
调用 isSelectionAllBold()   根据 getCurrentDisplayStyle() 切换
     ↓             ↓
┌──────────────────────┐  设置当前输入样式
│ 选区内全部加粗？      │
└──────────┬───────────┘
           │
    ┌──────┴──────┐
    │ 是          │ 否
    ↓             ↓
设置为 false    设置为 true
(取消加粗)       (加粗)
     ↓             ↓
FormatController::setBold(newBold)
     ↓
FormatController::applyCharacterStyle(style)
     ↓
遍历选中的块（支持跨多个段落）
     ↓
创建 SetCharacterStyleCommand
     ↓
推入 UndoStack
     ↓
ParagraphBlock::setStyle() 被调用
     ↓
分割 Span，应用样式，合并相邻 Span
     ↓
发出 textChanged() 信号
     ↓
TextBlockItem 更新显示
     ↓
MainWindow::updateStyleState() 更新工具栏状态
```

---

### 3.2 详细步骤说明

#### 步骤 1：用户点击加粗按钮

用户在 RibbonBar 工具栏上点击加粗按钮。

---

#### 步骤 2：RibbonBar 发出信号

**文件**: `src/ui/ribbon/RibbonBar.cpp:139-148`

```cpp
d->boldAction = new QAction(tr("B"), this);
d->boldAction->setCheckable(true);
// 使用 triggered 信号，不依赖按钮的 toggled 状态
connect(d->boldAction, &QAction::triggered,
        this, [this]() {
            // 使用 QSignalBlocker 防止 setChecked 触发信号
            QSignalBlocker blocker(d->boldAction);
            // 发出信号，由 MainWindow 处理实际切换
            emit boldChanged(false);  // 参数值会被忽略
        });
```

**关键点**：
- 使用 `QAction::triggered` 信号，而不是 `toggled` 信号
- 使用 `QSignalBlocker` 防止后续调用 `setChecked()` 时触发信号
- 发出的 `boldChanged(false)` 信号中的参数值会被忽略，只作为通知

---

#### 步骤 3：MainWindow 槽函数被调用

**文件**: `src/ui/mainwindow/MainWindow.cpp:202-236`

```cpp
connect(m_ribbonBar, &RibbonBar::boldChanged,
        this, [this](bool /* bold */) {
    qDebug() << "MainWindow: 加粗按钮被点击";
    
    CharacterStyle style;
    if (m_selection->isEmpty()) {
        // ========== 无选区的情况 ==========
        CharacterStyle currentStyle = m_formatController->getCurrentDisplayStyle();
        qDebug() << "  无选区，getCurrentDisplayStyle() 返回的加粗:" << currentStyle.bold();
        bool newBold = !currentStyle.bold();
        qDebug() << "  计算的新加粗:" << newBold;
        style.setBold(newBold);
        m_formatController->setCurrentInputStyle(style);
    } else {
        // ========== 有选区的情况 ==========
        bool allBold = m_formatController->isSelectionAllBold();
        
        qDebug() << "  有选区，选区内全部加粗:" << allBold;
        
        bool newBold;
        if (allBold) {
            // 选区内全部都是加粗 → 取消加粗
            newBold = false;
            qDebug() << "  选区内全部加粗，设置为 false";
        } else {
            // 选区内不一致或未加粗 → 设置为加粗
            newBold = true;
            qDebug() << "  选区内不一致或未加粗，设置为 true";
        }
        
        style.setBold(newBold);
        m_formatController->setBold(newBold);
    }
    updateStyleState();
});
```

**分支 A：无选区**
- 调用 `FormatController::getCurrentDisplayStyle()` 获取当前光标位置前一个字符的样式
- 取反后，调用 `FormatController::setCurrentInputStyle()` 设置新输入样式
- 调用 `MainWindow::updateStyleState()` 更新工具栏

**分支 B：有选区**
- 调用 `FormatController::isSelectionAllBold()` 检查选区内是否全部加粗
  - 支持**跨多个段落**的检查
  - 如果 `allBold == true` → 设置为 `false`（取消加粗）
  - 如果 `allBold == false` → 设置为 `true`（加粗）
- 调用 `FormatController::setBold(newBold)` 应用样式
- 调用 `MainWindow::updateStyleState()` 更新工具栏

---

#### 步骤 4：FormatController::setBold()

**文件**: `src/editcontrol/formatting/FormatController.cpp`

```cpp
void FormatController::setBold(bool bold)
{
    CharacterStyle style;
    style.setBold(bold);
    applyCharacterStyle(style);
}
```

- 创建一个新的 `CharacterStyle` 对象
- 设置该对象的 `bold` 属性
- 调用 `applyCharacterStyle(style)` 应用样式

---

#### 步骤 5：FormatController::applyCharacterStyle()

**文件**: `src/editcontrol/formatting/FormatController.cpp:30-79`

```cpp
void FormatController::applyCharacterStyle(const CharacterStyle &style)
{
    if (!m_document || !m_selection)
        return;
    
    SelectionRange range = m_selection->range();
    if (range.isEmpty())
        return;
    
    range.normalize();
    
    // 遍历选择范围内的每个块（支持跨多个段落）
    for (int blockIndex = range.startBlock; blockIndex <= range.endBlock; ++blockIndex) {
        Block *block = m_document->block(blockIndex);
        if (!block)
            continue;
        
        ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
        if (!paraBlock)
            continue;
        
        // 计算当前块的起始和结束偏移量
        int startOffset = (blockIndex == range.startBlock) ? range.startOffset : 0;
        int endOffset = (blockIndex == range.endBlock) ? range.endOffset : paraBlock->length();
        
        if (startOffset >= endOffset)
            continue;
        
        // 创建并推入命令
        SetCharacterStyleCommand *cmd = new SetCharacterStyleCommand(
            m_document, blockIndex, startOffset, endOffset, style);
        m_document->undoStack()->push(cmd);
    }
}
```

- 规范化选区范围
- 遍历选区内的**每个块（支持跨多个段落）**
- 对每个块：
  - 计算该块内的起始和结束偏移
  - 创建 `SetCharacterStyleCommand` 命令
  - 将命令推入文档的撤销堆栈

---

#### 步骤 6：SetCharacterStyleCommand::redo()

**文件**: `src/core/commands/SetCharacterStyleCommand.cpp`

命令推入撤销堆栈后，会立即执行 `redo()`：
- 调用 `ParagraphBlock::setStyle(start, length, style)`
- 保存旧样式以便后续撤销

---

#### 步骤 7：ParagraphBlock::setStyle()

**文件**: `src/core/document/ParagraphBlock.cpp:100-263`

这是核心的样式应用逻辑！

```
输入：start, length, style
      ↓
计算 end = start + length
      ↓
找到起始和结束的 Span
      ↓
    ┌──────────────────┐
    │ 在同一个 Span 内？  │
    └────────┬─────────┘
             │
    ┌────────┴────────┐
    │ 是              │ 否
    ↓                 ↓
分割成三个部分       处理起始 Span
before/middle/after    ──────────────────
                       分割成 before/after
                       before 用原始样式
                       after 用合并后的样式
                       ↓
                    处理中间 Span（完全在选区内）
                    直接用合并后的样式修改
                       ↓
                    处理结束 Span
                       ──────────────────
                       分割成 before/after
                       before 用合并后的样式
                       after 用原始样式
                       ↓
                    合并相邻的相同样式的 Span
                       ↓
                    发出 textChanged() 信号
```

**核心逻辑**：
1. 如果选区在同一个 Span 内：
   - **关键**：在删除原始 Span 前，**显式保存原始样式的副本** `CharacterStyle originalStyle = span.style();`
   - 分割成三个部分：before（选区前）、middle（选区内）、after（选区后）
   - before 和 after 保持原始样式
   - middle 使用 `originalStyle.mergeWith(style)` 合并后的样式

2. 如果选区跨多个 Span：
   - **起始 Span**：分割成 before（选区前）和 after（选区后）
     - before 保持原始样式
     - after 使用合并后的样式
   - **中间 Span**（完全在选区内）：直接使用合并后的样式修改
   - **结束 Span**：分割成 before（选区内）和 after（选区外）
     - before 使用合并后的样式
     - after 保持原始样式
   - **合并**：合并相邻的相同样式的 Span

3. 最后发出 `textChanged()` 信号

---

#### 步骤 8：TextBlockItem 更新

**文件**: `src/graphics/items/TextBlockItem.cpp`

当 `ParagraphBlock` 发出 `textChanged()` 信号时：
- `TextBlockItem::updateBlock()` 被调用
- `applyRichTextFromBlock()` 重新构建富文本
- 使用 HTML 格式，包含：
  - 内联 CSS 样式：`font-family`、`font-size`
  - HTML 标签：`<b>`（粗体）、`<i>`（斜体）、`<u>`（下划线）
- 界面显示更新

---

#### 步骤 9：MainWindow::updateStyleState()

**文件**: `src/ui/mainwindow/MainWindow.cpp`

最后调用 `updateStyleState()` 更新工具栏状态：
- 调用 `FormatController::getCurrentDisplayStyle()` 获取应该显示的样式
- 调用 `FormatController::getSelectionStyleConsistency()` 获取各属性的一致性
- 调用 `RibbonBar::updateFromSelection()` 更新工具栏按钮状态

---

## 四、各种情况详细说明

### 4.1 情况 1：无选区，点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查选区为空 |
| 2 | 调用 `getCurrentDisplayStyle()` 获取光标前一个字符的样式 |
| 3 | 取反（如果当前是 false，变成 true；反之亦然） |
| 4 | 调用 `setCurrentInputStyle()` 设置新输入样式 |
| 5 | 调用 `updateStyleState()` 更新工具栏 |

**结果**：后续输入的文字会使用新的加粗状态

---

### 4.2 情况 2：单个 Span 内选择，未加粗，点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查有选区 |
| 2 | 调用 `isSelectionAllBold()` → 返回 false |
| 3 | 设置为 true（加粗） |
| 4 | 调用 `applyCharacterStyle()` |
| 5 | 创建命令，推入撤销堆栈 |
| 6 | `ParagraphBlock::setStyle()` 分割 Span，应用样式 |
| 7 | 发出 `textChanged()`，界面更新 |
| 8 | 调用 `updateStyleState()`，工具栏加粗按钮亮起 |

**结果**：选区内文字加粗，工具栏显示加粗

---

### 4.3 情况 3：单个 Span 内选择，已加粗，点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查有选区 |
| 2 | 调用 `isSelectionAllBold()` → 返回 true |
| 3 | 设置为 false（取消加粗） |
| 4 | 调用 `applyCharacterStyle()` |
| 5 | 创建命令，推入撤销堆栈 |
| 6 | `ParagraphBlock::setStyle()` 分割 Span，应用样式 |
| 7 | 发出 `textChanged()`，界面更新 |
| 8 | 调用 `updateStyleState()`，工具栏加粗按钮熄灭 |

**结果**：选区内文字取消加粗，工具栏不显示加粗

---

### 4.4 情况 4：跨多个 Span 选择，部分加粗，点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查有选区 |
| 2 | 调用 `isSelectionAllBold()` → 检查所有重叠的 Span（包括跨段落），发现有非加粗的，返回 false |
| 3 | 设置为 true（加粗） |
| 4 | 调用 `applyCharacterStyle()` |
| 5 | 创建命令，推入撤销堆栈 |
| 6 | `ParagraphBlock::setStyle()` 处理跨 Span 情况：<br>  - 起始 Span：分割，after 部分加粗<br>  - 中间 Span：全部加粗<br>  - 结束 Span：分割，before 部分加粗<br>  - 合并相邻 Span |
| 7 | 发出 `textChanged()`，界面更新 |
| 8 | 调用 `updateStyleState()`，工具栏加粗按钮亮起 |

**结果**：选区内所有文字都加粗，工具栏显示加粗

---

### 4.5 情况 5：跨多个 Span 选择，已全部加粗，再次点击加粗

| 步骤 | 行为 |
|------|------|
| 1 | 检查有选区 |
| 2 | 调用 `isSelectionAllBold()` → 检查所有重叠的 Span（包括跨段落），全部都是加粗，返回 true |
| 3 | 设置为 false（取消加粗） |
| 4 | 调用 `applyCharacterStyle()` |
| 5 | 创建命令，推入撤销堆栈 |
| 6 | `ParagraphBlock::setStyle()` 处理跨 Span 情况：<br>  - 起始 Span：分割，after 部分取消加粗<br>  - 中间 Span：全部取消加粗<br>  - 结束 Span：分割，before 部分取消加粗<br>  - 合并相邻 Span |
| 7 | 发出 `textChanged()`，界面更新 |
| 8 | 调用 `updateStyleState()`，工具栏加粗按钮熄灭 |

**结果**：选区内所有文字都取消加粗，工具栏不显示加粗

---

## 五、关键方法说明

### 5.1 FormatController::isSelectionAllBold()

**文件**: `src/editcontrol/formatting/FormatController.cpp:572-620`

```cpp
bool FormatController::isSelectionAllBold() const
{
    if (!m_selection || m_selection->isEmpty()) {
        return false;
    }
    
    SelectionRange range = m_selection->range();
    
    if (range.startBlock < 0) {
        return false;
    }
    
    // 遍历从 startBlock 到 endBlock 的所有块（支持跨段落）
    for (int blockIndex = range.startBlock; blockIndex <= range.endBlock; ++blockIndex) {
        Block *block = m_document->block(blockIndex);
        ParagraphBlock *paraBlock = qobject_cast<ParagraphBlock*>(block);
        if (!paraBlock) {
            continue;
        }
        
        // 计算当前块的起始和结束偏移量
        int blockStartOffset = (blockIndex == range.startBlock) ? range.startOffset : 0;
        int blockEndOffset = (blockIndex == range.endBlock) ? range.endOffset : paraBlock->length();
        
        // 检查当前块中与选区重叠的 Span
        int currentOffset = 0;
        for (int i = 0; i < paraBlock->spanCount(); ++i) {
            const Span &span = paraBlock->span(i);
            int spanStart = currentOffset;
            int spanEnd = spanStart + span.text().length();
            
            // 检查 span 是否与选区重叠
            if (!(spanEnd <= blockStartOffset || spanStart >= blockEndOffset)) {
                // 如果有一个 span 的粗体是 false，那么就返回 false
                if (!span.style().bold()) {
                    return false;
                }
            }
            
            currentOffset = spanEnd;
        }
    }
    
    return true;
}
```

**职责**：检查选区内所有字符的粗体是否都为 true（支持跨多个段落）

**逻辑**：
1. 如果无选区 → 返回 false
2. **遍历从 startBlock 到 endBlock 的所有块**（支持跨段落）
3. 对于每个块：
   - 计算该块内的起始和结束偏移
   - 遍历该块的所有 Span
   - 对于每个与选区重叠的 Span：
     - 如果该 Span 的 `bold` 是 false → 立即返回 false
4. 如果所有重叠 Span 的 `bold` 都是 true → 返回 true

**类似方法**：
- `isSelectionAllItalic()`：检查选区内所有字符的斜体是否都为 true
- `isSelectionAllUnderline()`：检查选区内所有字符的下划线是否都为 true

---

### 5.2 CharacterStyle::mergeWith()

**文件**: `src/core/document/CharacterStyle.cpp:259-293`

```cpp
CharacterStyle CharacterStyle::mergeWith(const CharacterStyle &other) const
{
    CharacterStyle result = *this;
    
    // 只合并另一个样式中已显式设置的属性
    if (other.isPropertySet(CharacterStyleProperty::FontFamily)) {
        result.setFontFamily(other.fontFamily());
    }
    if (other.isPropertySet(CharacterStyleProperty::FontSize)) {
        result.setFontSize(other.fontSize());
    }
    if (other.isPropertySet(CharacterStyleProperty::Bold)) {
        result.setBold(other.bold());
    }
    if (other.isPropertySet(CharacterStyleProperty::Italic)) {
        result.setItalic(other.italic());
    }
    if (other.isPropertySet(CharacterStyleProperty::Underline)) {
        result.setUnderline(other.underline());
    }
    // ... 其他属性
    
    return result;
}
```

**职责**：将另一个样式合并到当前样式

**逻辑**：
- 保留当前样式的所有属性
- 只覆盖另一个样式中**已显式设置**的属性
- 使用 `isPropertySet()` 来判断某个属性是否已设置

---

## 六、总结

| 功能 | 说明 |
|------|------|
| **信号机制** | 使用 `QAction::triggered` 信号配合 `QSignalBlocker`，避免循环触发 |
| **工具栏显示** | 支持属性级别的一致性检测，跨 Span 时一致的属性仍会显示 |
| **按钮点击（无选区）** | 根据当前光标位置样式切换，影响后续输入 |
| **按钮点击（有选区）** | 根据选区内实际状态决定：<br> - 全部已设置 → 取消<br> - 未全部设置 → 设置 |
| **样式应用** | 使用 `ParagraphBlock::setStyle()` 分割和合并 Span，显式保存样式副本避免隐式共享 |
| **跨段落支持** | `isSelectionAllXxx()` 和 `applyCharacterStyle()` 都支持跨多个段落 |
| **撤销/重做** | 使用命令模式，支持完整的撤销/重做 |

---

## 七、技术要点更新（v2.0）

### 7.1 信号机制优化

- **之前**：使用 `toggled` 信号，容易造成循环触发
- **现在**：使用 `triggered` 信号 + `QSignalBlocker`，确保信号只在用户点击时发出

### 7.2 跨段落支持

- **之前**：只支持单个段落内的样式检查和应用
- **现在**：`isSelectionAllXxx()` 和 `applyCharacterStyle()` 都支持遍历多个块（段落）

### 7.3 样式副本保存

- **关键改进**：在 `ParagraphBlock::setStyle()` 中，删除原始 Span 前**显式保存样式副本**
- **原因**：避免 Qt 的隐式共享机制导致的样式污染问题

### 7.4 富文本渲染

- **使用 HTML 标签 + 内联 CSS**：
  - `<b>`、`<i>`、`<u>` 标签用于粗体、斜体、下划线（兼容性更好）
  - 内联 CSS `font-family`、`font-size` 用于字体族和字号
