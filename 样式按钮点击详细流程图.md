# QtWordEditor 样式按钮点击详细流程图

**日期**: 2026-02-19 14:30:00

---

## 目录
1. [总体流程图](#总体流程图)
2. [MainWindow 处理流程](#mainwindow-处理流程)
3. [isSelectionAllBold() 详细流程](#isselectionallbold-详细流程)
4. [applyCharacterStyle() 详细流程](#applycharacterstyle-详细流程)
5. [SetCharacterStyleCommand::redo() 流程](#setcharacterstylecommandredo-流程)
6. [ParagraphBlock::setStyle() 详细流程](#paragraphblocksetstyle-详细流程)
7. [updateStyleState() 流程](#updatestylestate-流程)

---

## 总体流程图

```mermaid
flowchart TD
    A[用户点击样式按钮<br>加粗/斜体/下划线] --> B[RibbonBar 发出信号<br>boldChanged/italicChanged/underlineChanged]
    B --> C[MainWindow Lambda槽函数被调用]
    C --> D{有选区吗?}
    
    D -->|否| E[无选区流程]
    D -->|是| F[有选区流程]
    
    E --> G[调用 getCurrentDisplayStyle]
    G --> H[切换当前样式]
    H --> I[调用 setCurrentInputStyle]
    
    F --> J[调用 isSelectionAllXxx]
    J --> K{选区内全部<br>已设置样式?}
    K -->|是| L[设置为 false<br>取消样式]
    K -->|否| M[设置为 true<br>应用样式]
    L --> N[调用 setXxx]
    M --> N
    
    I --> O[调用 updateStyleState]
    N --> O
    
    O --> P[结束]
```

---

## MainWindow 处理流程

```mermaid
flowchart TD
    A[MainWindow 槽函数开始] --> B[创建 CharacterStyle 对象]
    B --> C{selection isEmpty?}
    
    C -->|是| D[无选区处理]
    C -->|否| E[有选区处理]
    
    D --> F[调用 getCurrentDisplayStyle]
    F --> G[获取当前显示样式]
    G --> H[!currentStyle bold 取反]
    H --> I[style setBold newBold]
    I --> J[setCurrentInputStyle style]
    
    E --> K[调用 isSelectionAllBold]
    K --> L{allBold == true?}
    L -->|是| M[newBold = false<br>取消加粗]
    L -->|否| N[newBold = true<br>设置加粗]
    M --> O[style setBold newBold]
    N --> O
    O --> P[setBold newBold]
    
    J --> Q[调用 updateStyleState]
    P --> Q
    
    Q --> R[槽函数结束]
```

---

## isSelectionAllBold() 详细流程

```mermaid
flowchart TD
    A[isSelectionAllBold 开始] --> B{!m_selection 或 m_selection isEmpty?}
    B -->|是| C[return false]
    B -->|否| D[获取 SelectionRange]
    
    D --> E{range startBlock != range endBlock?}
    E -->|是| F[return false<br>跨多个块]
    E -->|否| G{range startBlock < 0?}
    G -->|是| H[return false]
    G -->|否| I[获取 Block]
    
    I --> J{ParagraphBlock 转换成功?}
    J -->|否| K[return false]
    J -->|是| L[初始化 currentOffset = 0]
    
    L --> M[i = 0; i < spanCount; ++i]
    M --> N{循环结束?}
    N -->|否| O[获取第 i 个 Span]
    O --> P[计算 spanStart = currentOffset]
    P --> Q[计算 spanEnd = spanStart + text length]
    
    Q --> R{Span 与选区重叠?}
    R -->|否| S[currentOffset = spanEnd<br>继续下一个]
    R -->|是| T{span style bold == false?}
    T -->|是| U[return false<br>发现非加粗]
    T -->|否| V[currentOffset = spanEnd<br>继续下一个]
    
    S --> M
    V --> M
    
    N -->|是| W[return true<br>全部都是加粗]
    
    C --> X[函数结束]
    F --> X
    H --> X
    K --> X
    U --> X
    W --> X
```

---

## applyCharacterStyle() 详细流程

```mermaid
flowchart TD
    A[applyCharacterStyle 开始] --> B{!m_document 或 !m_selection?}
    B -->|是| C[return]
    B -->|否| D[获取 SelectionRange]
    
    D --> E{range isEmpty?}
    E -->|是| F[return]
    E -->|否| G[range normalize]
    
    G --> H[blockIndex = range startBlock]
    H --> I{blockIndex <= range endBlock?}
    I -->|否| J[函数结束]
    I -->|是| K[获取 Block]
    
    K --> L{ParagraphBlock 转换成功?}
    L -->|否| M[blockIndex++<br>继续循环]
    L -->|是| N[计算 startOffset]
    
    N --> O{blockIndex == range startBlock?}
    O -->|是| P[startOffset = range startOffset]
    O -->|否| Q[startOffset = 0]
    
    P --> R[计算 endOffset]
    Q --> R
    
    R --> S{blockIndex == range endBlock?}
    S -->|是| T[endOffset = range endOffset]
    S -->|否| U[endOffset = paraBlock length]
    
    T --> V{startOffset >= endOffset?}
    U --> V
    
    V -->|是| W[blockIndex++<br>跳过]
    V -->|否| X[创建 SetCharacterStyleCommand]
    
    X --> Y[m_document undoStack push cmd]
    Y --> Z[blockIndex++<br>继续循环]
    
    W --> I
    Z --> I
```

---

## SetCharacterStyleCommand::redo() 流程

```mermaid
flowchart TD
    A[redo 开始] --> B[获取 ParagraphBlock]
    B --> C{!m_firstRedo?}
    C -->|是| D[直接调用 paragraphBlock setStyle]
    D --> E[m_firstRedo = false]
    
    C -->|否| F[首次执行<br>计算 end = start + length]
    F --> G[遍历 start 到 end 的所有字符]
    G --> H[保存旧样式到 m_oldStyles]
    H --> I[调用 paragraphBlock setStyle]
    
    E --> J[发出 textChanged 信号]
    I --> J
    
    J --> K[redo 结束]
```

---

## ParagraphBlock::setStyle() 详细流程

```mermaid
flowchart TD
    A[setStyle 开始] --> B[计算 end = start + length]
    B --> C[初始化 currentOffset = 0]
    C --> D[i = 0; i < m_spans size; ++i]
    
    D --> E{找到起始 Span?}
    E -->|否| F[currentOffset += span text length<br>i++]
    E -->|是| G[startSpanIndex = i<br>startSpanOffset = start - currentOffset]
    
    F --> D
    G --> H[继续查找结束 Span]
    
    H --> I{找到结束 Span?}
    I -->|否| J[currentOffset += span text length<br>i++]
    I -->|是| K[endSpanIndex = i<br>endSpanOffset = end - currentOffset]
    
    J --> H
    K --> L{startSpanIndex == endSpanIndex?}
    
    L -->|是| M[同一个 Span 处理]
    L -->|否| N[跨多个 Span 处理]
    
    M --> O[分割成三个部分<br>before/middle/after]
    O --> P[before 0 到 startSpanOffset<br>保持原样式]
    P --> Q[middle startSpanOffset 到 endSpanOffset<br>使用合并后的样式]
    Q --> R[after endSpanOffset 到末尾<br>保持原样式]
    R --> S[替换原 Span]
    
    N --> T[处理起始 Span]
    T --> U[分割起始 Span<br>before/after]
    U --> V[before 保持原样式]
    V --> W[after 使用合并后的样式]
    W --> X[处理中间 Span<br>完全在选区内]
    
    X --> Y[直接替换中间 Span 的样式]
    Y --> Z[处理结束 Span]
    Z --> AA[分割结束 Span<br>before/after]
    AA --> AB[before 使用合并后的样式]
    AB --> AC[after 保持原样式]
    AC --> AD[合并相邻相同样式的 Span]
    
    S --> AE[发出 textChanged 信号]
    AD --> AE
    
    AE --> AF[setStyle 结束]
```

---

## updateStyleState() 流程

```mermaid
flowchart TD
    A[updateStyleState 开始] --> B{selection isEmpty?}
    
    B -->|是| C[无选区<br>调用 getCurrentDisplayStyle]
    B -->|否| D[有选区<br>调用 getSelectionStyleConsistency]
    
    C --> E[获取 displayStyle]
    D --> F[获取 consistency]
    
    E --> G[准备更新工具栏]
    F --> G
    
    G --> H[更新粗体按钮状态]
    H --> I[更新斜体按钮状态]
    I --> J[更新下划线按钮状态]
    J --> K[更新字体下拉框]
    K --> L[更新字号下拉框]
    
    L --> M[调用 ribbonBar updateFromSelection]
    M --> N[updateStyleState 结束]
```

---

## 完整流程串联图（无选区情况）

```mermaid
flowchart TD
    A[用户点击加粗按钮] --> B[RibbonBar boldChanged]
    B --> C[MainWindow 槽函数]
    C --> D[无选区]
    D --> E[getCurrentDisplayStyle]
    E --> F[取反当前加粗状态]
    F --> G[setCurrentInputStyle]
    G --> H[updateStyleState]
    H --> I[工具栏显示新状态]
```

---

## 完整流程串联图（有选区情况）

```mermaid
flowchart TD
    A[用户点击加粗按钮] --> B[RibbonBar boldChanged]
    B --> C[MainWindow 槽函数]
    C --> D[有选区]
    D --> E[isSelectionAllBold]
    E --> F{全部加粗?}
    F -->|是| G[设置为 false]
    F -->|否| H[设置为 true]
    G --> I[setBold newBold]
    H --> I
    I --> J[applyCharacterStyle]
    J --> K[创建 SetCharacterStyleCommand]
    K --> L[推入 UndoStack]
    L --> M[ParagraphBlock setStyle]
    M --> N[分割/合并 Span]
    N --> O[发出 textChanged]
    O --> P[TextBlockItem 更新显示]
    P --> Q[updateStyleState]
    Q --> R[工具栏更新]
```

---

## 关键数据流向图

```mermaid
flowchart LR
    A[用户输入] -->|点击| B[RibbonBar UI]
    B -->|信号| C[MainWindow]
    C -->|调用| D[FormatController]
    D -->|创建| E[SetCharacterStyleCommand]
    E -->|推入| F[UndoStack]
    F -->|执行| G[ParagraphBlock]
    G -->|修改| H[Span 数据]
    H -->|发出信号| I[TextBlockItem]
    I -->|更新| J[界面显示]
    C -->|调用| K[updateStyleState]
    K -->|更新| B
```

---

## 总结

本流程图详细展示了从用户点击样式按钮到界面最终更新的完整流程，包括：

1. **主流程**：从用户点击到工具栏更新的完整链路
2. **子流程**：每个关键方法的详细执行步骤
3. **分支处理**：无选区和有选区两种情况的不同处理逻辑
4. **数据流向**：数据在各个组件之间的传递过程

所有流程图都基于实际代码逻辑绘制，可作为开发和调试的参考文档。
