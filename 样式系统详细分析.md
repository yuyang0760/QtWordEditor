# QtWordEditor 样式系统详细分析

## 目录
1. [当前架构概述](#当前架构概述)
2. [核心类详解](#核心类详解)
3. [工作流程分析](#工作流程分析)
4. [存在的问题](#存在的问题)
5. [接下来的改进计划](#接下来的改进计划)

---

## 当前架构概述

### 样式系统架构图

```
┌─────────────────────────────────────────────────────────────────────────┐
│                              用户界面层                                   │
│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐       │
│  │  FormatToolBar  │  │   FontDialog    │  │ ParagraphDialog │       │
│  └────────┬────────┘  └────────┬────────┘  └────────┬────────┘       │
└───────────┼────────────────────┼─────────────────────┼─────────────────┘
            │                    │                     │
┌───────────▼────────────────────▼─────────────────────▼─────────────────┐
│                           FormatController                               │
│  ┌───────────────────────────────────────────────────────────────────┐  │
│  │  applyCharacterStyle()  setBold()  setItalic()  setTextColor()...│  │
│  │  applyParagraphStyle()  setAlignment()  setIndent()...            │  │
│  └───────────────────────────────────────────────────────────────────┘  │
└───────────┬──────────────────────────────────────────────────────────────┘
            │
┌───────────▼──────────────────────────────────────────────────────────────┐
│                              命令层                                        │
│  ┌──────────────────────────┐  ┌──────────────────────────┐            │
│  │ SetCharacterStyleCommand │  │ SetParagraphStyleCommand │            │
│  └──────────────────────────┘  └──────────────────────────┘            │
└───────────┬──────────────────────────────────────────────────────────────┘
            │
┌───────────▼──────────────────────────────────────────────────────────────┐
│                             文档层                                         │
│  ┌─────────────────────────────────────────────────────────────────────┐ │
│  │  Document                                                            │ │
│  │    └── ParagraphBlock (多个)                                        │ │
│  │          └── Span (多个)                                            │ │
│  │               ├── text (QString)                                    │ │
│  │               └── style (CharacterStyle)                           │ │
│  │    └── StyleManager                                                 │ │
│  │          ├── m_characterStyles (QHash<QString, CharacterStyle>)   │ │
│  │          └── m_paragraphStyles (QHash<QString, ParagraphStyle>)   │ │
│  └─────────────────────────────────────────────────────────────────────┘ │
└───────────────────────────────────────────────────────────────────────────┘
```

### 样式类型

1. **直接样式（Direct Formatting）**
   - 直接应用于文本 Span 的样式
   - 存储在 Span::m_style 中
   - 优先级最高

2. **命名样式（Named Styles）**
   - 由 StyleManager 管理的样式模板
   - 通过名称引用
   - 当前未完全实现

---

## 核心类详解

### 1. CharacterStyle（字符样式类）

**文件位置：**
- 头文件：`include/core/document/CharacterStyle.h`
- 实现文件：`src/core/document/CharacterStyle.cpp`

**类定义：**
```cpp
class CharacterStyle {
private:
    struct CharacterStyleData : public QSharedData {
        QFont m_font;
        QColor m_textColor;
        QColor m_backgroundColor;
        qreal m_letterSpacing;
    };
    QSharedDataPointer<CharacterStyleData> d;
};
```

**核心属性：**
| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| m_font | QFont | "Times New Roman", 12pt | 字体对象 |
| m_textColor | QColor | Qt::black | 文字颜色 |
| m_backgroundColor | QColor | Qt::transparent | 背景颜色 |
| m_letterSpacing | qreal | 0.0 | 字符间距 |

**公共方法：**
- `font() / setFont()` - 获取/设置完整字体
- `fontFamily() / setFontFamily()` - 获取/设置字体族
- `fontSize() / setFontSize()` - 获取/设置字体大小
- `bold() / setBold()` - 获取/设置粗体
- `italic() / setItalic()` - 获取/设置斜体
- `underline() / setUnderline()` - 获取/设置下划线
- `strikeOut() / setStrikeOut()` - 获取/设置删除线
- `textColor() / setTextColor()` - 获取/设置文字颜色
- `backgroundColor() / setBackgroundColor()` - 获取/设置背景颜色
- `letterSpacing() / setLetterSpacing()` - 获取/设置字符间距
- `operator== / operator!=` - 样式比较
- `reset()` - 重置为默认样式

**隐式共享机制：**
- 使用 `QSharedDataPointer` 实现写时复制（Copy-on-Write）
- 多个 CharacterStyle 对象可以共享同一份数据
- 只有在修改时才会复制数据，提高性能

---

### 2. ParagraphStyle（段落样式类）

**文件位置：**
- 头文件：`include/core/document/ParagraphStyle.h`
- 实现文件：`src/core/document/ParagraphStyle.cpp`

**类定义：**
```cpp
class ParagraphStyle {
private:
    struct ParagraphStyleData : public QSharedData {
        ParagraphAlignment m_alignment;
        qreal m_firstLineIndent;
        qreal m_leftIndent;
        qreal m_rightIndent;
        qreal m_spaceBefore;
        qreal m_spaceAfter;
        int m_lineHeight;
    };
    QSharedDataPointer<ParagraphStyleData> d;
};
```

**核心属性：**
| 属性 | 类型 | 默认值 | 说明 |
|------|------|--------|------|
| m_alignment | ParagraphAlignment | AlignLeft | 对齐方式 |
| m_firstLineIndent | qreal | 0.0 | 首行缩进 |
| m_leftIndent | qreal | 0.0 | 左缩进 |
| m_rightIndent | qreal | 0.0 | 右缩进 |
| m_spaceBefore | qreal | 0.0 | 段前间距 |
| m_spaceAfter | qreal | 0.0 | 段后间距 |
| m_lineHeight | int | 100 | 行高百分比 |

**对齐方式枚举：**
```cpp
enum class ParagraphAlignment {
    AlignLeft,      // 左对齐
    AlignCenter,    // 居中对齐
    AlignRight,     // 右对齐
    AlignJustify    // 两端对齐
};
```

---

### 3. Span（文本片段类）

**文件位置：**
- 头文件：`include/core/document/Span.h`
- 实现文件：`src/core/document/Span.cpp`

**类定义：**
```cpp
class Span {
private:
    class SpanData : public QSharedData {
    public:
        QString m_text;
        CharacterStyle m_style;
    };
    QSharedDataPointer<SpanData> d;
};
```

**核心属性：**
| 属性 | 类型 | 说明 |
|------|------|------|
| m_text | QString | 文本内容 |
| m_style | CharacterStyle | 字符样式 |

**公共方法：**
- `text() / setText()` - 获取/设置文本
- `append()` - 追加文本
- `insert()` - 插入文本
- `remove()` - 删除文本
- `length()` - 获取文本长度
- `style() / setStyle()` - 获取/设置样式
- `split()` - 分割 Span
- `operator== / operator!=` - 比较

---

### 4. StyleManager（样式管理器类）

**文件位置：**
- 头文件：`include/core/styles/StyleManager.h`
- 实现文件：`src/core/styles/StyleManager.cpp`

**类定义：**
```cpp
class StyleManager : public QObject {
private:
    Document *m_document;
    QHash<QString, CharacterStyle> m_characterStyles;
    QHash<QString, ParagraphStyle> m_paragraphStyles;
};
```

**核心属性：**
| 属性 | 类型 | 说明 |
|------|------|------|
| m_document | Document* | 关联的文档 |
| m_characterStyles | QHash&lt;QString, CharacterStyle&gt; | 字符样式哈希表 |
| m_paragraphStyles | QHash&lt;QString, ParagraphStyle&gt; | 段落样式哈希表 |

**默认样式（initializeDefaultStyles）：**

**字符样式：**
| 样式名称 | 字体大小 | 粗体 | 斜体 |
|----------|----------|------|------|
| Default | 12pt | false | false |
| Heading 1 | 24pt | true | false |
| Heading 2 | 20pt | true | false |
| Heading 3 | 18pt | true | false |
| Emphasis | 12pt | false | true |
| Strong | 12pt | true | false |

**段落样式：**
| 样式名称 | 段前间距 | 段后间距 | 左缩进 | 右缩进 |
|----------|----------|----------|--------|--------|
| Default | 0 | 0 | 0 | 0 |
| Heading 1 | 12 | 12 | 0 | 0 |
| Heading 2 | 10 | 10 | 0 | 0 |
| Quote | 0 | 0 | 30 | 30 |

**公共方法：**
- `initializeDefaultStyles()` - 初始化默认样式
- `setDocument() / document()` - 设置/获取关联文档
- `addCharacterStyle() / characterStyle() / hasCharacterStyle() / characterStyleNames()` - 字符样式管理
- `addParagraphStyle() / paragraphStyle() / hasParagraphStyle() / paragraphStyleNames()` - 段落样式管理
- `applyCharacterStyle()` - 应用字符样式（**未实现**）
- `applyParagraphStyle()` - 应用段落样式（**未实现**）

---

### 5. FormatController（格式控制器类）

**文件位置：**
- 头文件：`include/editcontrol/formatting/FormatController.h`
- 实现文件：`src/editcontrol/formatting/FormatController.cpp`

**类定义：**
```cpp
class FormatController : public QObject {
private:
    Document *m_document;
    Selection *m_selection;
};
```

**核心方法：**

**字符格式化：**
- `applyCharacterStyle(const CharacterStyle &style)` - 应用完整字符样式
- `setFont(const QFont &font)` - 设置字体
- `setFontSize(int size)` - 设置字体大小
- `setBold(bool bold)` - 设置粗体
- `setItalic(bool italic)` - 设置斜体
- `setUnderline(bool underline)` - 设置下划线
- `setTextColor(const QColor &color)` - 设置文字颜色
- `setBackgroundColor(const QColor &color)` - 设置背景颜色

**段落格式化：**
- `applyParagraphStyle(const ParagraphStyle &style)` - 应用完整段落样式
- `setAlignment(ParagraphAlignment align)` - 设置对齐方式
- `setLeftIndent(qreal indent)` - 设置左缩进
- `setRightIndent(qreal indent)` - 设置右缩进
- `setFirstLineIndent(qreal indent)` - 设置首行缩进
- `setLineHeight(int percent)` - 设置行高
- `setSpaceBefore(qreal space)` - 设置段前间距
- `setSpaceAfter(qreal space)` - 设置段后间距

---

## 工作流程分析

### 1. 设置粗体的流程

```
用户点击"粗体"按钮
        ↓
FormatToolBar::onBoldClicked()
        ↓
FormatController::setBold(true)
        ↓
遍历选择范围内的每个位置
        ↓
获取当前位置的 CharacterStyle
        ↓
创建新的 CharacterStyle = 当前样式
        ↓
newStyle.setBold(true)
        ↓
创建 SetCharacterStyleCommand
        ↓
推入 QUndoStack
        ↓
执行 redo()
        ↓
ParagraphBlock::setStyle(start, length, newStyle)
        ↓
重建 Span 列表
        ↓
合并相邻的相同样式 Span
        ↓
更新文档布局
        ↓
刷新显示
```

### 2. 应用样式到 Span 的详细过程

**ParagraphBlock::setStyle() 方法：**

```cpp
void ParagraphBlock::setStyle(int start, int length, const CharacterStyle &style)
{
    QList<Span> newSpans;
    int currentPos = 0;
    
    // 遍历所有旧的 Span
    for (const Span &oldSpan : m_spans) {
        int spanStart = currentPos;
        int spanEnd = currentPos + oldSpan.length();
        
        // 分割成三个部分：before / middle / after
        QString beforeText = oldSpan.text().left(start - spanStart);
        QString middleText = oldSpan.text().mid(start - spanStart, length);
        QString afterText = oldSpan.text().mid(start - spanStart + length);
        
        // 重新构建 Span 列表
        if (!beforeText.isEmpty()) {
            newSpans.append(Span(beforeText, oldSpan.style()));
        }
        if (!middleText.isEmpty()) {
            newSpans.append(Span(middleText, style));
        }
        if (!afterText.isEmpty()) {
            newSpans.append(Span(afterText, oldSpan.style()));
        }
        
        currentPos = spanEnd;
    }
    
    m_spans = newSpans;
    mergeAdjacentSpans();  // 合并相邻的相同样式 Span
}
```

---

## 存在的问题

### 问题 1：CharacterStyle 没有"属性已设置"标记

**问题描述：**
```cpp
class CharacterStyleData {
    QFont m_font;           // 默认值：Times New Roman, 12pt
    QColor m_textColor;     // 默认值：Qt::black
    // ...
};
```

所有属性都有默认值，但无法区分：
- 这个属性是用户显式设置的
- 还是使用的默认值

**导致的问题：**
- 合并样式时，不知道应该保留哪些属性
- 可能会意外覆盖用户已设置的属性

### 问题 2：StyleManager 的 apply 方法未实现

**问题描述：**
```cpp
void StyleManager::applyCharacterStyle(const QString &styleName, int blockIndex, int start, int end)
{
    Q_UNUSED(blockIndex);
    Q_UNUSED(start);
    Q_UNUSED(end);
    if (!hasCharacterStyle(styleName))
        return;
    // TODO: create a command and push onto undo stack
}
```

**影响：**
- 命名样式系统无法实际使用
- 用户无法通过名称应用样式

### 问题 3：Span 不支持引用命名样式

**当前实现：**
```cpp
class SpanData {
    QString m_text;
    CharacterStyle m_style;  // 直接保存样式
};
```

**应该支持：**
```cpp
class SpanData {
    QString m_text;
    QString m_styleName;              // 命名样式名称（可选）
    CharacterStyle m_directStyle;     // 直接样式（可选，覆盖命名样式）
};
```

### 问题 4：没有样式继承机制

**问题：**
- 无法让一个样式基于另一个样式
- 例如："Heading 2" 基于 "Heading 1"，只修改字体大小

### 问题 5：修改命名样式不会自动更新文本

**问题：**
- 如果修改了 "Heading 1" 的样式定义
- 所有使用 "Heading 1" 的文本不会自动更新

### 问题 6：FormatController 的 applyCharacterStyle 可能覆盖属性

**问题：**
```cpp
void FormatController::applyCharacterStyle(const CharacterStyle &style)
{
    // 当前实现会把整个样式应用上去
    // 可能会覆盖用户已设置的其他属性
}
```

---

## 接下来的改进计划

### 阶段 1：完善 CharacterStyle - 添加属性设置标记

**目标：** 让 CharacterStyle 能够追踪哪些属性是用户显式设置的

**任务清单：**

1.1 **修改 CharacterStyleData 结构**
   - 添加 `m_propertySetFlags` 位掩码
   - 定义属性标志枚举

```cpp
enum class CharacterStyleProperty {
    FontFamily     = 1 << 0,
    FontSize       = 1 << 1,
    Bold           = 1 << 2,
    Italic         = 1 << 3,
    Underline      = 1 << 4,
    StrikeOut      = 1 << 5,
    TextColor      = 1 << 6,
    BackgroundColor = 1 << 7,
    LetterSpacing  = 1 << 8
};
Q_DECLARE_FLAGS(CharacterStylePropertyFlags, CharacterStyleProperty)

class CharacterStyleData {
    // ... 现有属性 ...
    CharacterStylePropertyFlags m_propertySetFlags;
};
```

1.2 **修改所有 setter 方法**
   - 在设置属性时设置对应的标志位

```cpp
void CharacterStyle::setBold(bool bold)
{
    if (d->m_font.bold() != bold) {
        d->m_font.setBold(bold);
        d->m_propertySetFlags |= CharacterStyleProperty::Bold;
    }
}
```

1.3 **添加属性查询方法**
   - `isPropertySet(CharacterStyleProperty property)`
   - `clearProperty(CharacterStyleProperty property)`
   - `clearAllProperties()`

1.4 **添加样式合并方法**
   - `mergeWith(const CharacterStyle &other)` - 合并两个样式
   - 只合并已设置的属性

```cpp
CharacterStyle CharacterStyle::mergeWith(const CharacterStyle &other) const
{
    CharacterStyle result = *this;
    
    if (other.isPropertySet(CharacterStyleProperty::Bold)) {
        result.setBold(other.bold());
    }
    if (other.isPropertySet(CharacterStyleProperty::Italic)) {
        result.setItalic(other.italic());
    }
    // ... 其他属性
    
    return result;
}
```

**预计工作量：** 2-3 小时

---

### 阶段 2：完善 ParagraphStyle - 添加属性设置标记

**目标：** 让 ParagraphStyle 也能追踪哪些属性是用户显式设置的

**任务清单：**

2.1 **修改 ParagraphStyleData 结构**
   - 添加 `m_propertySetFlags` 位掩码
   - 定义属性标志枚举

2.2 **修改所有 setter 方法**
   - 在设置属性时设置对应的标志位

2.3 **添加属性查询方法**
   - `isPropertySet()`
   - `clearProperty()`

2.4 **添加样式合并方法**
   - `mergeWith(const ParagraphStyle &other)`

**预计工作量：** 1-2 小时

---

### 阶段 3：实现 StyleManager 的 apply 方法

**目标：** 让 StyleManager 能够实际应用命名样式

**任务清单：**

3.1 **实现 StyleManager::applyCharacterStyle()**
   - 根据样式名称获取样式
   - 创建 SetCharacterStyleCommand
   - 推入 QUndoStack

```cpp
void StyleManager::applyCharacterStyle(const QString &styleName, int blockIndex, int start, int end)
{
    if (!hasCharacterStyle(styleName))
        return;
    
    CharacterStyle style = characterStyle(styleName);
    
    if (!m_document)
        return;
    
    // 创建命令并推入撤销栈
    SetCharacterStyleCommand *cmd = new SetCharacterStyleCommand(
        m_document, blockIndex, start, end, style);
    m_document->undoStack()->push(cmd);
}
```

3.2 **实现 StyleManager::applyParagraphStyle()**
   - 根据样式名称获取样式
   - 创建 SetParagraphStyleCommand
   - 推入 QUndoStack

**预计工作量：** 1 小时

---

### 阶段 4：修改 Span 支持命名样式引用

**目标：** 让 Span 可以引用命名样式，同时支持直接样式覆盖

**任务清单：**

4.1 **修改 SpanData 结构**
```cpp
class SpanData : public QSharedData {
public:
    QString m_text;
    QString m_styleName;              // 命名样式名称
    CharacterStyle m_directStyle;     // 直接样式（覆盖命名样式）
};
```

4.2 **修改 Span 的公共方法**
   - `styleName() / setStyleName()` - 获取/设置样式名称
   - `directStyle() / setDirectStyle()` - 获取/设置直接样式
   - `effectiveStyle()` - 获取最终生效的样式（命名样式 + 直接样式）

```cpp
CharacterStyle Span::effectiveStyle(const StyleManager *styleManager) const
{
    CharacterStyle result;
    
    // 1. 如果有命名样式，先应用
    if (!d->m_styleName.isEmpty() && styleManager) {
        if (styleManager->hasCharacterStyle(d->m_styleName)) {
            result = styleManager->characterStyle(d->m_styleName);
        }
    }
    
    // 2. 然后用直接样式覆盖
    result = result.mergeWith(d->m_directStyle);
    
    return result;
}
```

4.3 **修改 ParagraphBlock::setStyle()**
   - 支持设置样式名称
   - 支持设置直接样式

4.4 **修改渲染代码**
   - 使用 `effectiveStyle()` 而不是 `style()`

**预计工作量：** 3-4 小时

---

### 阶段 5：实现样式继承机制

**目标：** 让样式可以基于其他样式

**任务清单：**

5.1 **修改 StyleManager 存储结构**
```cpp
struct CharacterStyleInfo {
    CharacterStyle style;
    QString parentStyleName;  // 父样式名称
};

QHash<QString, CharacterStyleInfo> m_characterStyles;
```

5.2 **添加样式继承方法**
   - `setCharacterStyleParent(const QString &styleName, const QString &parentStyleName)`
   - `getResolvedCharacterStyle(const QString &styleName)` - 解析继承后的完整样式

5.3 **实现样式解析逻辑**
   - 递归合并父样式属性

```cpp
CharacterStyle StyleManager::getResolvedCharacterStyle(const QString &styleName) const
{
    if (!hasCharacterStyle(styleName))
        return CharacterStyle();
    
    const CharacterStyleInfo &info = m_characterStyles.value(styleName);
    CharacterStyle result = info.style;
    
    // 如果有父样式，递归合并
    if (!info.parentStyleName.isEmpty()) {
        CharacterStyle parentStyle = getResolvedCharacterStyle(info.parentStyleName);
        result = parentStyle.mergeWith(result);
    }
    
    return result;
}
```

**预计工作量：** 2-3 小时

---

### 阶段 6：实现样式修改自动更新文本

**目标：** 修改命名样式后，所有使用该样式的文本自动更新

**任务清单：**

6.1 **在 Document 中追踪样式使用情况**
   - 记录每个命名样式被哪些 Span 使用

```cpp
class Document {
private:
    // 样式名称 -> 使用该样式的 Span 位置列表
    QHash<QString, QList<SpanLocation>> m_styleUsage;
};
```

6.2 **修改 StyleManager，在样式修改时发出信号**
```cpp
signals:
    void characterStyleChanged(const QString &styleName);
    void paragraphStyleChanged(const QString &styleName);
```

6.3 **Document 监听样式变化信号**
   - 收到信号后，更新所有使用该样式的 Span

6.4 **创建批量更新命令**
   - 支持一次更新多个 Span 的样式

**预计工作量：** 3-4 小时

---

### 阶段 7：完善 FormatController

**目标：** 让 FormatController 正确处理样式合并

**任务清单：**

7.1 **修改 FormatController::applyCharacterStyle()**
   - 使用 CharacterStyle::mergeWith() 合并样式
   - 只合并已设置的属性

7.2 **添加从 StyleManager 应用样式的方法**
   - `applyNamedCharacterStyle(const QString &styleName)`
   - `applyNamedParagraphStyle(const QString &styleName)`

7.3 **添加获取当前选区内样式的方法**
   - `getCurrentCharacterStyle()` - 获取选区内的字符样式
   - `getCurrentParagraphStyle()` - 获取选区内的段落样式

**预计工作量：** 2 小时

---

### 阶段 8：UI 集成

**目标：** 在界面上显示和选择命名样式

**任务清单：**

8.1 **在 FormatToolBar 中添加样式下拉框**
   - 显示所有可用的字符样式
   - 显示所有可用的段落样式

8.2 **实现样式选择功能**
   - 选择样式后应用到当前选区

8.3 **实时更新样式状态**
   - 光标移动时，显示当前位置的样式名称

8.4 **创建样式管理对话框**
   - 添加新样式
   - 编辑现有样式
   - 删除样式
   - 设置样式继承关系

**预计工作量：** 4-5 小时

---

### 阶段 9：序列化支持

**目标：** 保存和加载命名样式

**任务清单：**

9.1 **修改 XmlSerializer**
   - 保存 StyleManager 中的所有样式
   - 保存 Span 的样式名称引用
   - 保存样式继承关系

9.2 **测试序列化**
   - 保存文档
   - 重新加载
   - 验证样式是否正确恢复

**预计工作量：** 2-3 小时

---

## 总工作量估算

| 阶段 | 工作量 | 累计 |
|------|--------|------|
| 阶段 1：CharacterStyle 属性标记 | 2-3 小时 | 2-3 小时 |
| 阶段 2：ParagraphStyle 属性标记 | 1-2 小时 | 3-5 小时 |
| 阶段 3：实现 StyleManager apply | 1 小时 | 4-6 小时 |
| 阶段 4：Span 支持命名样式 | 3-4 小时 | 7-10 小时 |
| 阶段 5：样式继承 | 2-3 小时 | 9-13 小时 |
| 阶段 6：样式自动更新 | 3-4 小时 | 12-17 小时 |
| 阶段 7：完善 FormatController | 2 小时 | 14-19 小时 |
| 阶段 8：UI 集成 | 4-5 小时 | 18-24 小时 |
| 阶段 9：序列化支持 | 2-3 小时 | 20-27 小时 |

**总计：约 20-27 小时（3-4 个工作日）**

---

## 优先级建议

### 高优先级（必须实现）：
1. 阶段 1：CharacterStyle 属性标记
2. 阶段 2：ParagraphStyle 属性标记
3. 阶段 3：实现 StyleManager apply 方法
4. 阶段 7：完善 FormatController

### 中优先级（建议实现）：
5. 阶段 4：Span 支持命名样式
6. 阶段 8：UI 集成（基础部分）
7. 阶段 9：序列化支持

### 低优先级（可选实现）：
8. 阶段 5：样式继承
9. 阶段 6：样式自动更新
10. 阶段 8：UI 集成（高级部分）

---

## 总结

当前样式系统的核心问题是：
1. **CharacterStyle/ParagraphStyle** 没有属性设置标记
2. **StyleManager** 的 apply 方法未实现
3. **Span** 不支持命名样式引用
4. 没有样式继承和自动更新机制

建议按照优先级逐步实现，先完成高优先级的任务，让基本的命名样式功能可用。
